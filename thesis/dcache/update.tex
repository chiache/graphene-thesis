\section{Trading {\tt Rename} with {\tt Lookup}}
\label{sec:dcache:update}

The Linux kernels are designed with consideration of concurrency and
scalability on multi-core machines.
These concerns are especially important in the directory cache,
because it is a feature constantly queried by multiple processes on different cores.
When the design of directory cache lookup has taken account of
concurrency,
it must guarantee data in \dentries{} or pointers dereferencing in both \dentries{} and hash buckets never be corrupted
by racy interleaving of directory cache access on different cores.
In concern of scalability,
synchronization of the directory cache must do better than naively serializing any operations for coherence and atomicity.

In this section, we suggest to improve directory cache by optimistically removing synchronization operations in lookup.
It is a common strategy to improve scalability in systems
to allow read-only accesses to happen without atomicity, by forcing write accesses to either wait or be deferred.
This strategy optimistically assumes write accesses happen much less frequently
than read-only accesses,
so it will not cause significant degradation of overall performance.

\subsection{Synchronization Cost in the Directory Cache}

In Linux kernels, the directory cache is protected with two synchronization options:
one is locking with reference counting in \dentries{},
and the other is sequence counting with read-copy-update (RCU) support.
Each synchronization option requires a specific implementation of lookup routine
to guarantee that it will not access corrupted data or dereference pointers to destroyed objects:

\begin{compactitem}

\item With locking and reference counting,
the lookup routine performs a {\tt reference walk} in the directory cache.
It first locks the hash table to search among \dentries{} that are chained together,
and then locks the found \dentry{} to increment its reference count
and access the data.

\item With sequence counting and RCU,
the lookup routine performs a {\tt RCU walk} in the directory cache.
It first uses a global lock to force all concurrent update to the hash table be
deferred by RCU.
The global locking will defer updates to chains of \dentries{} in hash buckets,
as well as deallocation of \dentries{}.
Once the \dentry{} is found, the lookup routine will determine the atomicity
for accessing multiple fields of the \dentry{},
by checking whether the sequence counting is advanced.

\end{compactitem}

With either {\tt reference walk} or {\tt RCU walk},
the lookup routine must guarantee three constraints of synchronizations
in the directory cache.
First, the chains of \dentries{} must not be broken by concurrent insertion or deletion.
Second, while accessing any \dentry{}, the \dentry{} must not be destroyed
for deletion or cache shrinking.
Last, the related fields in a \dentry{} must be accessed atomically.
For example, the file name must be consistent with the length of file name stored.

The lookup routines that use {\tt reference walk} and {\tt RCU walk} have different cost of synchronization.
With {\tt reference walk}, the lookup routine needs to acquire a global lock for the hash table,
and individual locks for every \dentry{} it has visited.
Each operation of locking or unlocking requires at least one instruction of compare-and-change {{\tt cmpxchg}).
With {\tt RCU walk}, the lookup routine only needs to acquire one global locking,
and checking sequence counting for every \dentry{} it has visited.
Checking sequence counting requires a memory barrier to ensure
CPU to wait for completion of memory access
before rechecking the sequence counting.
In general, RCU walk is much more efficient than reference walk because
a memory barrier is mostly cheaper than a pair of compare-and-change instructions.
\fixmetsai{show some evidence here}
In Linux's component-based lookup, it mostly tries {\tt RCU walk} first, but falls back
to {\tt reference walk} when {\tt RCU walk} is not sufficient for synchronization.

\subsection{Reduce Synchronization Cost in Lookup}

\subsection{Special Cases}

\fixmetsai{We will revisit this section when we have better idea, or just remove it.}
