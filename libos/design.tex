\section{The \thelibos{} Implementation}


The \graphene{} \libos{}, or \thelibos{},
is a single library to be loaded beneath a Linux executable and other libraries,
for exporting compatible features.
\thelibos{} facilitates the execution of an unmodified Linux application,
by combining with a PAL and a host OS to behave as an equivalence of a Linux kernel. 
%which is developed upon the assumption of running on a Linux kernel or equivalent.
The main purpose of \thelibos{} is to reproduce
the idiosyncratic features and behaviors of Linux,
or the {\bf Linux personality},
to resurrect Linux applications upon incompatible
host OSes or hardware.
\thelibos{} is developed as an application-level, ELF dynamic library (i.e., \code{\tt libLinux.so}),
to be loaded on a host by the corresponding PAL.
%at the beginning of a \picoproc{}.


A key component implemented by \thelibos{}
is a Linux system call table, which redirects \linuxapi{} invocations from a Linux application as function calls.
%a key Linux kernel component applications. 
%that \thelibos{} implements is the Linux system call table.
For Linux and similar OSes,
a system call table is the primary entry point to the kernel space,
and triggers in-kernel operations for servicing requests from applications.
%and defines the interaction between applications and kernel.
\graphene{} moves the Linux system call table into \thelibos{},
and implements a number of \linuxapi{} handlers in the user space.
%The system call table in \thelibos{} contains a number of \linuxapi{} handlers,
These \linuxapi{} handlers emulate
individual \linuxapis{} supported in \graphene{};
the development of each \linuxapi{} handler
is mostly based on a specification known by the Linux application developers,
as described in the Linux manpages~\cite{linux-man-syscall}.
Otherwise, for a few \linuxapis{} whose behaviors
are not clearly defined by the Linux manpages,
such as \syscall{rt\_sigaction},
the \linuxapi{} handlers mimic the bug-for-bug behaviors of an actual Linux kernel.
%A continuing goal in \graphene{} is
%to extend \thelibos{} with more complete \linuxapi{} handlers.


%grow the functionality of \thelibos{},
%by extending the system call table with more complete handlers.




%The development of \linuxapi{} handlers in \thelibos{}
%is equivalent to implementing the specifications described in the Linux man pages~\cite{linux-man-syscall},
%including the valid inputs to each \linuxapi{},
%as well as the expected outcome.


%\paragraph{Implementing Linux Personality.} 
%\fixmedp{Revisit the logical flow of these paragraphs}
\Thelibos{} currently implements \graphenesyscallnum{} \linuxapis{},
which are sufficient for running a range of applications from servers, command-line programs, to language runtimes.
For reference,
a relatively recent Linux kernel defines more than three hundred \linuxapis{}, including a long tail of infrequently-used \linuxapis{}.
%upon \thehostabi{}. % to interact with the host.
%Among the whole Linux \linuxapi{} table,
%A Linux kernel exports a long tail of infrequently-used \linuxapis{}.
%For reference, the Linux \linuxversion{} kernel exports \linuxsyscallnum{} \linuxapis{}.
A study of the Linux \linuxapi{} usage~\cite{tsai16apistudy}
indicates that only forty \linuxapis{} are indispensable to every applications available in the Ubuntu official repositories.
%The study also shows that
In the meantime, more than a hundred \linuxapis{} are used by only a single application,
or no application at all.
The development of \thelibos{} begins with
implementing twelve basic \linuxapis{} needed for running a ``hello world'' application,
such as \syscall{read}, \syscall{write}, and \syscall{open},
and then gradually grows the count of \linuxapis{}.
%for each new application introduced to run on \graphene{}.
As the count of \linuxapis{} continues to grow,
each time \thelibos{} is tested against a new application, the number of \linuxapis{} that need to be added
has dropped.
%Based on the types of applications priorized in \graphene{}, including servers, command-line programs, and language runtimes, some \linuxapis{} to be more important %for reusing the applications
%than the others. % \linuxapis{}.
According to the usage of each \linuxapi{} in applications,
developers can prioritize the popular \linuxapis{}, over other \linuxapis{} that are either unpopular among applications, or only used by administrative tools such as \code{reboot} or \code{ifconfig}.
\thelibos{} demonstrates that
\thehostabi{} is sufficient for implementing
a significant subset of the Linux \linuxapis{} to run
a representative sample of applications.


%The current \thelibos{} implementation
%includes a set of high-valued Linux \linuxapis{} for the types of applications
%that \graphene{} has targeted,
%including servers, command-line programs, and runtimes.
%The remaning \linuxapis{} may require extending \thehostabi{} with more privileged abstractions,
%including administrative operations
%and host-specific features.
%\thelibos{} demonstrates that \thehostabi{} is sufficient
%for exporting the host abstractions, to support a representative sample of Linux applications.

%such as memory sharing, scheduler configuration, and NUMA (non-uniform memory architecture) support.


%Linux exports a very long tail of infrequently-used \linuxapis{}.
%applications.




%An analysis indicates roughly 100 additional calls that can be implemented
%with the existing \pal{} ABI and coordination framework, less than 10 administrative calls that will not make sense to expose to 
%an application, such as loading a kernel module or rebooting the system, and roughly 54 that will require 
%\pal{} extensions to meaningfully implement, such as controlling scheduling,
%NUMA placement, I/O privilege, and shared memory.
%In the last category of system calls, the degree to which actual host details should be exported versus emulated is debatable.

%We believe represent the most commonly used system calls.
%When an application requests a call or argument that {\tt libLinux.so} does not implement,
%the picoprocess exits with a distinct error message. 
%Each time we have tested \graphene{} with a new application, the number of extra system calls
%required has dropped---most recently we only added 4 calls
%(namely, epoll\_create, epoll\_wait, semget and semop)
%to support the Apache web server.
%Thus, we believe \graphene{} implements a representative sample of Linux calls.

%such as {\tt sched\_setparam}, which manipulates scheduler-specific
%parameters or 
%{\tt uselib}, which has been abandoned 
%in {\tt glibc} version 2 in favor of a user-space dynamic linker.
%We do not plan to implement administrative interfaces, such as {\tt reboot}.
%The growth in the set of supported system calls has been driven by 
%the requirements of new applications we use to exercise \graphene{}, and has been 
%slowing considerably over time.



\subsection{\Linuxapi{} redirection}


\thelibos{} mimics a Linux kernel. A Linux kernel assigns an interrupt handler for \linuxapis{} triggered by an application, using ``\code{syscall}'' or ``\code{int \$80}'' instructions.
A \linuxapi{} interrupt handler
ensures the context switches from applications to the kernel,
and passes up to six \linuxapi{} arguments given by applications to kernel routines that services the \linuxapis{}.
%based on a kernel convention agreed by applications and Linux kernels.
To supported unmodified applications,
\thelibos{}
intercepts the \linuxapis{}
in an executable or library binary, and redirect the \linuxapis{}
to the \linuxapi{} handlers inside \thelibos{}.
%\thelibos{} implements the callback functions for a subset of the Linux \linuxapis{}.
%For reference, Linux kernel \linuxversion{}
%has defined \linuxsyscallnum{} \linuxapis{} in total.


For most unmodified Linux applications,
\thelibos{} redirects \linuxapis{} using a modified C library (\libc{}).
%from an unmodified Linux application.
In general,  a Linux executable or user library does not invoke \linuxapis{} directly.
Instead, \linuxapis{}
are usually wrapped by \libc{} functions,
which internally execute the \assembly{syscall} instructions.
%an executable or library in Linux and similar OSes invokes \linuxapis{} through \libc{},
%instead of directly containing the \code{syscall} instructions.
%The \libc{}
%contains a large set of \linuxapi{} wrappers,
%which encapsulate direct \linuxapis{} to the kernel as functions.
For example, an application usually calls \syscall{read} as a \libc{} function, which is a direct wrapper to the \linuxapi{} that bares the same name and definition.
By defualt,
\thelibos{} uses a patched version
of the {\bf GNU C library (\glibc{})}~\cite{glibc},
which is compatible against most of the Linux applications released for Ubuntu.
%Other \libc{} variants, ,
%which are either fully or partially compatible with \glibc{},
%can be also modified to redirect \linuxapis{} to \thelibos{}.
%are alternatives upon \thelibos{} as long as they are modified for .
However, \graphene{} is not dedicated to \glibc{}, since 
other \libc{} variants,
such as \projname{uClibc}~\cite{uclibc} and \projname{musl}~\cite{musl},
are also demonstrated
to be acceptable alternatives,
with slight modification for \linuxapi{} redirection.




For \linuxapi{} redirection,
\graphene{} has restricted the modification in \glibc{}
to a small amount of
internal functions or macros.
The C source code in \glibc{} has consistently referenced a single macro called
\funcname{INLINE\_SYSCALL}.
%when it needs to invoke a \linuxapi{}.
\funcname{INLINE\_SYSCALL} is written as a wrapper of the inline assembly code
that copies the \linuxapi{} number and arguments to the corresponding registers,
and executes the \code{syscall} instruction.
\graphene{} modifies \funcname{INLINE\_SYSCALL}
to redirect the control flow to
an entry point inside \thelibos{} called \funcname{syscalldb}.
Once \funcname{syscalldb} is called, it saves the current state of register context on the user stack, similar to doing a context switch into a Linux kernel.
\funcname{syscalldb} then jumps to the \linuxapi{} handler
indicated by the given \linuxapi{} number, to trigger operations inside \thelibos{}.
The only exception is the assembly code in \glibc{}, which has
to be modified at every \linuxapi{} invocations to redirect to \funcname{syscalldb}.
Figure~\ref{fig:syscall-redirection} summarizes the mechanism of \linuxapi{} redirection
from \glibc{} to \thelibos{}.


\graphene{} assumes deploying an application %to be deployed
with modified \glibc{} binaries,
including \code{libc.so}, \libpthread{}, and \libdl{}.
Despite that \glibc{} has partitioned its code into separate libraries, not every libraries need to be modified for \linuxapi{} redirection.
Only \code{libc.so}, \libpthread{}, and \libdl{} contain \code{syscall} instructions.
Other \libc{} libraries, such as \code{libm.so},
only invoke \linuxapis{} through existing \libc{} functions;
thus, \graphene{} leaves \code{libm.so} and similar \libc{} libraries unmodified.



\paragraph{Hard-coded \linuxapis{}.}
If a static executable or a platform-dependent binary
includes hard-coded \assembly{syscall} instructions,
a modified \libc{} would fail to redirect the \linuxapi{} invocations to the \linuxapi{} table in \thelibos{}. % from the binary.
An executable
statically linked against an unmodified \libc{}
includes
the \libc{} functions
with embedded \assembly{syscall} instructions.
Running these static executables with \graphene{} causes a security risk
of exposing the host resources and states to the application,
or a compatibility issue of corrupting the guest OS view on a Linux host.
Besides, some applications---usually a language runtime (e.g., the go runtime)
or system software---are programmed
%In some cases, application developers may program an application
with direct \linuxapi{} invocation,
using a piece of inline or standalone assembly code
containing
\code{syscall} instructions.


%Either way leads to hard-coding \code{syscall} instructions in the ELF binaries.
%Running an unmodified executable or library
%with \linuxapis{} that are not redirected to \thelibos{}
%has the risk of exposing
%unauthorized host resources and states
%to the application.


To redirect hard-coded \linuxapis{},
\thelibos{} depends on the host OS or hardware, to prevent an unexpected \linuxapi{} interrupt from entering the host kernel.
The host needs to restrict \linuxapi{} invocation,
by either installing a \linuxapi{} filter,
such as the Linux SECCOMP filter,
or capturing the hardware exception caused by illegal \linuxapis{},
%architectural limitation on \code{syscall} instructions
similar to the enclave restriction on SGX.
%The details of the \linuxapi{} restriction mechanisms are discussed in
%\fixme{update labels}
%Section~\ref{sec:linux:syscall} and Section~\ref{sec:sgx:syscall}.
\graphene{} encapsulates
the notification of a restricted \linuxapi{} as a host-level exception
defined in \thehostabi{};
\thelibos{} the uses \palcall{ExceptionSetHandler}
to assign a handler for illegal \linuxapi{} invocation.
The handler will
%If an application invokes an \linuxapi{} illegally,
%the host should trigger an exception as defined in \thehostabi{},
%and thus the \linuxapi{} is redirected by an exception handler
%assigned by \thelibos{}.
%The exception handler 
retrieve the \linuxapi{} number and arguments
from the saved context,
call the \linuxapi{} handler,
and push the \linuxapi{} return value back to the saved context.



Redirecting hard-coded \linuxapis{} by exception handling
can be relatively expensive,
due to the overhead of back-and-forth context switches.
Without triggering a host-level exception,
redirecting a \linuxapi{} through a modified \libc{} is much faster than
a \linuxapi{} on a Linux kernel.
However, if a \linuxapi{} is trapped by the host
and the host delivers an exception to the handler in \thelibos{},
at least four context switches
are needed for servicing a single \linuxapi{}.
A potential optimization is to rewrite %the binary, to replace 
a \assembly{SYSCALL} instruction
to jump to \funcname{syscalldb} in \thelibos{}.
%binary translation
%can be triggered when a host-level exception is raised
%for an illegal \linuxapi{},
\thelibos{} can either rewrite all the \assembly{syscall} instructions in
the whole binary when the binary is dynamically loaded,
or lazily replace the \assembly{syscall} instructions in the exception handler.

%to optimize consecutive \linuxapi{} invocation at the same location.
%\thelibos{} can also perform a full scan in application binaries
%to spot and modify hard-code \code{syscall} instructions.









\subsection{Bootstrapping}


\thelibos{}



