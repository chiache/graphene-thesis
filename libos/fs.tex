\subsection{File systems}
\label{sec:libos:fs}

This section will discuss the implementation of file systems in \thelibos{}, including a pass-through, sandboxed file system, the virtual file system layer for abstracting common file system operations, and other supported file system types.


\subsubsection{A pass-through file system}


A Linux application depends on a list of indispensable resources
within a POSIX-style, hierarchical file system.
A POSIX-style file system is composed of a number of directories and files, including a root directory (``/'') as the common ancestor.
A POSIX application searches each file or directory in the file system
by describing the {\em path} %to traverse
from the root directory to the target. % file or directory.
%For opening a file during execution,
An application either obtains a canonical or relative path
from a user interface or configuration,
or hard-codes the path in one of the application binaries.
An application can heavily rely on the existence of specific paths in a file system,
such as \code{/tmp} (a default temporary directory)
and \code{/bin} (a directory for system programs),
as well as the POSIX file system features,
such as directory listing and symbolic links.



\thelibos{} creates a consistent, guest file system view containing the file dependencies of an application.
%A file system in \thelibos{} can be a combination of multiple 
%partial file systems,
A basic file system type in \thelibos{} is a pass-through, sandboxed file system called a ``{\bf chroot (change root)}'' file system.
A chroot file system isolates a directory in the host file system,
and maps such directory
to a custom path inside \thelibos{}.
The mapping creates a restricted view for the application to access the files and directories inside the mounted host directory.
%If the application searches for a path under the mapped directory,
A chroot file simply replaces the prefix of each searched path
with the URI of the mounted host directory,
and redirects the file operations to the host using \thehostabi{}.
For an application, each chroot file system has cherry-picked
file resources in a host directory.
The host reference monitor ensures that
a chroot file system 
is sandboxed within the mounted host directory,
%within the host directories that are mounted as chroot file systems.
so that any \hostapis{} can only access files and directories under the host directory,
similar to a Linux program being \syscall{chroot}'ed
before running any untrusted execution.


 
%should ensure that any access in a chroot file system cannot escape the corresponding directory in the host (hence the name ``chroot''). 
%According to the user configuration, \thelibos{} can {\em mount} multiple chroot file systems to different paths in the guest file system,
%as a way of cherry-picking host file resources for an application.



For example, \thelibos{} can mount a host directory ``\code{file:/foo}'' as a chroot file system under ``\code{/bin}'' in the guest file system.
If the application search a path called ``\code{/bin/bash}'', \thelibos{} will translate the path to ``\code{file:/foo/bash}'', and redirects access of \code{/bin/bash} to \hostapis{} for accessing \code{file:/foo/bash} in the host OS.
Moreover, the host reference monitor enforces policies
to prevent the untrusted application
to escape the mapped directory, even if the application uses ``dot-dot'' to walk back to last level of directory; for example, \thelibos{} cannot redirect a path \code{/bin/../etc/passwd} to \code{file:/etc/passwd}, because \code{file:/etc/passwd} does not belong to the chroot file system mounted at \code{/bin}.
By mounting a chroot file system, \thelibos{} creates a sandbox that disguises an unprivileged local directory (i.e., \code{/foo})
as a privileged system directory (i.e., \code{/bin}) in an application.
  

The implementation of common file operations in a chroot file system is mostly as straightforward as translating to one or few \hostapis{}.
As previously stated, opening a file in a chroot file system
simply requires calling \palcall{StreamOpen} with the file URI translated from the requested path.
If the chroot file system successfully opens the file in the host,
it associates the returned PAL handle with a file descriptor, to translate common file system \linuxapis{} such as \syscall{pread} and \syscall{pwrite}
as \hostapis{} such as \palcall{StreamRead} ad \palcall{StreamWrite}, since \thehostabi{} defines these two \hostapis{} to be positionless.
For the more commonly-used \syscall{read} and \syscall{write},
%Besides any further optimization, 
the chroot file system
simply tracks the current offset of the file descriptor, and atomically retrieves and updates the offset in each \linuxapi{}.
%for implementing \syscall{read} and \syscall{write}
%are merely to store the PAL handle
%and to atomically retrieve and update the current offset inside the opened file.
The batched \syscall{readv} and \syscall{writev}
is translated to multiple \palcall{StreamRead} ad \palcall{StreamWrite} calls
on the same file.
Another two common \linuxapis{},
\syscall{stat} and \syscall{fstat}, which retrieve the metadata of a file or a directory,
need only one more step as
translating the returned host-level stream attributes
(i.e., \code{STREAM\_ATTR})
to the POSIX-style data structure (i.e., \code{struct stat}).


The definition of \thehostabi{} allows several opportunities of optimizing the latency of file system \linuxapi{}.
Two common techniques being broadly used in \thelibos{}
are buffering and caching.
To improve the latency of reading and writing a file,
\thelibos{} effectively buffers the content of multiple \syscall{read} and \syscall{write} \linuxapis{},
until the application calls \syscall{fsync} or the file offset exceeds the range of buffering.
Buffering file changes potentially delay the timing of writing the data
to physical disks,
but \thelibos{} accelerates the process
by making the buffer a pass-through mapping of the file (using \palcall{StreamMap}).
For an application which
performs lots of small, sequential reads or writes,
or lots of small, random reads or writes with significant spatial locality,
buffering the data
can significantly improve the performance;
evaluation shows that
running \projname{GCC} in \graphene{} to compile 0.7MLoC, on a Linux host, 
is only 1\% slower than running on Linux.
In terms of caching, \thelibos{} contains a file system directory cache
in the virtual file system,
which will aggressively cache any directory information
retrieved from \thehostabi{}.
The file system directory cache of \thelibos{} also benefits other file systems,
and the details will be further discussed in Section~\ref{sec:libos:vfs}.



A chroot file system enforces container-style sandboxing of an application,
but simultaneously
allows sharing part of the guest file system
with other applications and \picoprocs{}.
Since \thelibos{} supports mounting multiple chroot file systems in a \picoproc{},
\graphene{} users can configure a host to selectively export a few host directories containing the file resources in use.
The security isolation of a single chroot file system %enforces the security isolation
is similar to the sandboxing of a Linux container~\cite{lxc}, which restricts all the file operations of an application within a local file system tree unless the container is running on a stackable file system~\cite{aufs}.
\graphene{} allows multiple applications to share a host directory, either read-only or with full access,
and uses a host reference monitor
to enforce AppArmor~\cite{apparmor}-like, white-listed rules
for isolating every file access.
\graphene{} can share most of the system files and binaries,
such as \code{/etc/hosts} and \code{/bin/bash},
without compromising the security isolation of each application.





\subsubsection{Guest-level file systems}
%A file system in \thelibos{}

Another approach of implementing a guest file system
is to introduce a 



\thelibos{} also supports various types of file systems,
such as a pseudo file system
(e.g., a ``proc'' or ``devtmpfs'' file system).
A pseudo file system is not linked with any physical storage devices,
but a dummy file system
purely designed for retrieving or configuring OS kernel states.
A pseudo file system can be considered as an extension of the \linuxapi{} interface,
for exporting features with more administrative purposes.
A pseudo file system usually re-purposes the operations of a file system, such as \syscall{read}, \syscall{write}, and directory listing,
for administrative-type operations,
such as retrieving a process list and individual process status.
\thelibos{} has selectively implements a set of pseudo file system entries,
based on the importance to the applications targeted by \graphene{}.


\issuedone{1.2.e}{describe POSIX file system vs NFS/other approaches}








\subsubsection{A virtual file system layer}
\label{sec:libos:vfs}






\thelibos{} includes a {\bf virtual file system} layer for abstracting the operations
of different file systems.



such as the chroot file system, a pseudo file system (e.g., a ``proc'' or ``devtmpfs'' file system), and a networked file system (NFS).
Similar to the virtual file system in Linux,
the virtual file of \thelibos{} defines a set of file and directory operations that
each file system must implement.
When an application opens a file,
\thelibos{} searches all the mounted file systems for the target path,
and creates a generic file handle containing pointers
to the file and directory operations implemented by the residing file system.
\fixme{not enough explanation}
The virtual file system layer has decoupled
the implementation of \linuxapis{} and file system operations in \thelibos{}.







As a feature of the virtual file system, \thelibos{} implements
a local file system directory cache
to reduce the \hostapis{} for retrieving directory information
or attempting to access a nonexistent path.




%An application
%often depends on the existence of several paths,
%including paths that are conventional to a POSIX file system (e.g., ``\code{/bin}'', ``\code{/proc}'', and ``\code{/dev}'')







