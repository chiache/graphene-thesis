\section{Resource Management}
\label{sec:libos:resource}


\Thelibos{}
relies on the hosts to manage hardware and privileged OS resources.
\Thehostabi{}
defines a set of host abstractions---such as I/O streams, virtual memory areas (VMAs), and threads---for the development of a \libos{}.
%that are available for its guest.
These host abstractions delegate
the management of a few ubiquitously-installed hardware resources, such as I/O devices, memory, and CPUs,
to the host OSes.
Other abstractions defined
by \thehostabi{},
such as a local RPC stream and a system clock,
depend on low-level, privileged resources in the host OSes,
such as in-kernel queues and time sources.
To support \thelibos{} as a guest,
\thehostabi{} avoids the requirement of exposing or virtualizing %the management of
these hardware and privileged OS resources,
by encapsulating the resources as generic, user-space abstractions.
%of the host ABI.



\issuedone{1.2.a}{discuss the role of libOS in resource management}
The role of \thelibos{} in resource management
is to allocate the host abstractions,
as unambiguous requests %to the host
for the host-managed resources.
At a high level, the purpose of \thelibos{} is to recreate the Linux abstractions.
\Thelibos{} implements the Linux abstractions
based on managing the host abstractions instead of
the underlying resources.
For example, if a Linux abstraction requires allocating pages
for either usage in an application or
internal bookkeeping,
the implementation in
\thelibos{} will allocate a VMA, which is the memory abstraction of \thehostabi{}, instead of physical pages.
%in a unified, guest virtual address space.
Such a \libos{} design operates on the faith that the host OS will manage and assign pages to VMAs, with reasonable fairness as well as efficiency.
Unless the allocation exceeds user quotas or host limitations,
the \libos{} should be allowed to obtain more host-manged resources,
by increasing the allocation of a host abstraction.



The role of \thelibos{} in resource management is close to a language runtime, such as a Java virtual machine~\cite{hotspot,j9,alpern2000jalapeno}, or a Python~\cite{python} or Perl~\cite{perl} runtime.
A language runtime generally relies on system APIs exported by the OSes
for resource management.
A common behavior of a language runtime
is to use \linuxapis{} like \syscall{mmap} to allocate a large heap,
which is later chunked into objects
and assigned to variables in an application.
Similar strategies have been applied to
filesystem or threading abstractions in a language runtime. %, which %are likely to
%usually leverage the filesystem or threading APIs of the OSes.
%By managing the OS abstractions,
%exported by the OSes,
%the language runtime creates an independent view
%of system resources for applications.
%Such a design resonates with \thelibos{}. 



A primary task and challenge to managing resources in \thelibos{}
is to reproduce the idiosyncratic %resource allocation
features or requirements of Linux, % in Linux,
using only the host abstractions
defined by \thehostabi{}.
Take page management for example.
Linux contains several memory abstractions, including VMAs allocated by \syscall{mmap}, a self-growing stack in each process, and a fine-grained heap allocated by \syscall{brk}.
Since \thelibos{} does not directly manage pages,
it requires particular emulation strategies to
implement the allocation models that applications expect when using these Linux abstractions.
A strategy repeatedly used in \thelibos{} and language runtimes
is to ``overallocate'' certain host abstractions when an application requests for resources.
The purpose of overallocation is
to keep the flexibility of adjusting the resources afterward.
The caveat of using these kinds of strategies
is that they are based on an assumption that the host
allocates the resources
on demand, instead of populating the resources all at once.
However, such an assumption does not apply to all hosts;
%for an environment like a SGX enclave, overallocating resources such as virtual memory can still have a huge impact on resource footprints.
for example, the current version of SGX requires a static virtual memory layout,
and each VMA is at least fully populated once at enclave creation
for checking the integrity of memory data.
Therefore, overallocating VMAs slows down the creation of an enclave.
\fixme{End with a summary of the paragraph?}




%Since emulation has its cost,
%an important problem to solve in \thelibos{}








\paragraph{Alternatives.}
Virtualization is a common approach to allowing guest-level resource management for an application.
%managing resources in a guest OS
%is to virtualize the hardware resources,
%such as memory and IO devices,
There are two primary strategies to fully virtualize hardware resources for a guest OS.
The first strategy is to rely on a hypervisor,
such as QEMU~\cite{qemu} or VMWare ESX~\cite{wldspurger02vmware-esx},
to emulate the physical hardware,
giving the guest OS the illusion of having full control of all the hardware resources.
Another strategy to leverage the hardware virtualization,
such as IOMMU~\cite{VT-d},
which allows a hypervisor to dedicate physical hardware resources
to guest OS instances.
%Virtualization allows a guest OS to directly manage hardware resources, by either emulating a set of virtual hardware,
%or dedicating physical hardware to a guest OS instance.
Both of the virtualization strategies grant a guest OS with more control on managing hardware resources than \thelibos{} in the \graphene{} architecture.


%Compared with full virtualization, the \graphene{} approach
%The \thelibos{} design
%is similar to a para-virtualized guest OS,
%which calls out to the host OS or hypervisor for allocating resources.


Exokernel~\cite{engler95exokernel} also uses a \libos{}
to implement the system APIs and abstractions, but allows the \libos{} to manage hardware resources directly.
The rationale behind Exokernel is to avoid the kernel overhead of encapsulating and redirecting hardware resources.
Exokernel allows application-level resource management, by exposing low-level resources, such as physical pages, storage disks, and network devices, at the kernel interface.









\input{vma}
\input{fs}
\input{network}
\input{thread}






