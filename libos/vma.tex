\subsection{Virtual address space}
\label{sec:libos:vma}


\fixme{start with what applications need}
A Linux application usually expects a contiguous, large virtual address space,
to allocate a number of numerically-addressable memory regions.
A program usually uses a \libc{} allocator, requested by \funcname{malloc} and \funcname{calloc},
or a heap allocator of a managed language runtime,
or reserves space on the current stack,
to allocate fine-grained memory objects.
To support application-level allocation,
an OS is responsible of
maintaining a unique, consistent mapping between virtual memory areas (VMAs) and physical pages,
and managing the virtual address space layout
to prevent collision of VMAs.
The Linux kernel, specifically, provides several ways of memory allocation, such as calling \syscall{mmap} or \syscall{brk},
and transparently growing a stack when accessing beyond the stack boundary.
A application-level allocator may try several ways of requesting memory resources;
for example, the \glibc{} allocator
uses both \syscall{brk} and \syscall{mmap} to allocate different sizes of memory objects.
Applications depend on different memory allocation mechanisms
of a Linux kernel,
to dynamically allocate space for storing application data.
 



\thelibos{} manages VMAs of a virtual address space.
To emulate a Linux kernel,
\thelibos{} creates VMAs using two \hostapis{}:
\palcall{VirtMemAlloc} for creating an anonymous memory mapping,
and \palcall{StreamMap} for mapping a file into the virtual address space.
%or maps a file into a new VMA using \palcall{StreamMap}.
Both \hostapis{} creates a page-aligned, fixed range in the
virtual memory space,
with the assumption that the host OS or hypervisor
will assign a physical page to each virtual page being accessed,
and fill the physical page with file content or zeros.
\thelibos{} does not assume
a host to always implement demand paging.
The only assumption that \thelibos{} makes, when \palcall{VirtMemAlloc} or \palcall{StreamMap} returns successfully,
is that 
the the application or 
\thelibos{} is authorized to access any part of the created VMA,
without causing a segmentation fault
or memory protection fault.
It is possible that a host may have statically assign
physical pages to the whole VMA instead of gradually increasing the memory usage.

%each physical page of an allocated VMA
%will be assigned
%before any access to the page, including reading or writing data,
%or executing code.
%In other word, any future, authorized memory access
%in an allocated VMA
%should never cause any segmentation or memory protection faults.



\thelibos{} creates VMAs for two reasons.
First, \thelibos{} allocates memory regions on applications' request.
\thelibos{} also allocates memory for internal usages,
such as maintaining
the bookkeeping of OS states,
and reserving space for buffering and caching.
\thelibos{} contains a {\em slab allocator} (for internal \funcname{malloc}) and several object-caching memory allocators.
For each abstraction, \thelibos{} allocates a handle (e.g., a thread handle)
using internal allocation functions.
Therefore, the memory overhead of \thelibos{} %, regardless of the memory footprint of application itself,
is primarily caused by allocating various types of handles for maintaining or caching OS states,
and is roughly correlated with
the abstractions used by the application. 



%For example, \thelibos{} allocates a thread control block (TCB), or thread handle, for each user thread that an application creates, to store thread-specific attributes
%such as a thread identifier and a given stack address.
%To reduce the memory cost of \graphene{},
%\thelibos{} tries to reduce the VMA allocation for its internal usage
%as long as it does not add significant performance overhead to an application.
%Another usage of a VMA
%is to assign the VMA to a memory area that an application
%assumes to be accessible, such as a heap area created by \syscall{mmap} or a self-growing stack.
%If \thelibos{} allocates a VMA for supporting the memory access in an application,
%the VMA must be at least as large as the size that the application has requested.



In terms of page management,
the role of \thelibos{} is to keep track of memory addresses that already belong to a VMA.
In many cases,
an application or \thelibos{}
simply needs to allocate a new memory region that has not overlapped
with existing memory regions.
If an application gives a memory address
as an argument to a \linuxapi{},
\thelibos{} needs verifying the validity of address by checking against existing memory regions. 
As a result,
\thelibos{} maintains a list of currently-allocated VMAs,
and dynamically updates the list whenever allocating, deallocating, or protecting any memory mappings.
For each VMA, \thelibos{} records
the starting address, size, protection mode (whether the VMA is readable, writable, or executable), and usage of the VMA.




By maintaining a list of allocated VMAs,
%Instead of managing physical pages, 
\thelibos{} controls the virtual address space layout
of a guest environment (i.e., a \picoproc{}).
\thelibos{} keeps track of the free addresses in the current virtual address space,
to prevent allocating overlapping VMAs.
To allocate a VMA without a specific address,
\thelibos{} first walks the VMA list
to discover an unallocated, large enough address range.
Then, \thelibos{} can use \palcall{VirtMemAlloc} or \palcall{StreamMap} with the discovered address,
to create a memory mapping suitable for the expected usage.
Therefore, \thelibos{} can control the address
for allocating a new VMA,
to service a \syscall{mmap} \linuxapi{},
or to extend the internal slab allocator of \thelibos{}.
The bookkeeping of VMAs also includes
the VMAs preserved by PAL and the VMAs for the \thelibos{} binary mapping,
to prevent future VMAs
corrupting the internal states of PAL or \thelibos{}.
\thelibos{} records these VMAs at the beginning of a \picoproc{}, based on address ranges specified by the PAL control block.




To maintain a VMA list,
\thelibos{} needs to dynamically modify, shrink, or divide VMAs, to support all corner cases
of memory allocation.
Three key \linuxapis{} in Linux---\syscall{mmap}, \syscall{mprotect}, and \syscall{munmap}---permit allocation, protection, and deallocation of pages
at arbitrary page-aligned addresses.
If a \syscall{mmap}, \syscall{mprotect}, or \syscall{munmap} \linuxapi{}
partially frees or modifies a VMA,
\thelibos{} divides the VMA bookkeeping into two, and then destroys of rewrites one of the VMAs.
\thelibos{} is responsible of synchronizing the VMA lists of the host OS and \thelibos{}.



Arbitrary allocation and deallocation of VMAs can cause {\bf external fragmentation} in the virtual address space.
Arbitrarily freeing or shrinking existing VMAs
creates holes between the remaining VMAs, which may not be large enough
to accommodate future allocation.
Creating holes in the virtual address space
is normally acceptable if the virtual address space is enormously large and the host OS can swap out physical pages.
\thelibos{} can simply ignore the address space holes and
allocate new VMAs at higher or lower addresses. 
The assumption is problematic on a host where the virtual address space of
a guest is a limited resource.
For example, a SGX enclave has a limited virtual address space in the enclave, constrained by the enclave initialization.
As a result, external fragmentation in the virtual address space
can potentially cause a significant waste of resources on a specific host like SGX.


To reduce the impact of external fragmentation, \thelibos{} allows internal VMAs to interleave with the VMAs allocated by the application.
Despite that \thelibos{} cannot relocates VMAs
for defragmenting the whole virtual address space,
\thelibos{} can internally recycle fragmented space for buffering or expanding a slab allocator.
Interleaving different types of VMAs
helps filling up the fragmented free space
with smaller objects or buffers.
Moreover, there are opportunities to recycle or consolidate the internal heap of \thelibos{},
once \thelibos{} detects pressure on utilizing the virtual address space.
To sum up, \thelibos{} can recycle the holes between VMAs allocated by the application, and utilize the space for internal buffering or bookkeeping.



%Even if a address space hole
%is much smaller than a normal internal VMA, \thelibos{} can still repurpose the space
%to allocating a small amount of internal object.
%Unlike application VMAs, most internal VMAs can be recycled or relocated if \thelibos{} can trace back pointers to these VMAs.
%Because \thelibos{} interleaves different types of VMAs,
%there is opportunities for \thelibos{} to consolidate 





%\paragraph{Implementing \syscall{brk}.}

Take \syscall{brk} for example.
\syscall{brk} is a Linux \linuxapi{} for expanding or shrinking a fine-grained heap following the application's data segment.
Most applications 
use \syscall{brk} 
for its speed of allocating 
small objects by moving the top of heap by a small offset.
Different from \syscall{mmap},
\syscall{brk} only allocates a physical page
when moving the top of heap across page boundaries.
%to allow gradual allocation of application objects.
Some applications, such as \gcc{}, can bypass \syscall{brk} by switching to \syscall{mmap}.
However, to support other applications that depends on \syscall{brk},
\thelibos{} internally implements the fine-grained heap
based on VMAs.



\thelibos{} preallocates a \code{brk} area for future \syscall{brk} \linuxapis{}.
The \code{brk} area has a limited, configurable capacity,
and maintains a \code{brk} pointer to the top of heap currently assigned by the application.
Whenever the application calls \syscall{brk} (or \funcname{sbrk}, a \libc{} function internally calling \syscall{brk}),
\thelibos{} adjusts the \code{brk} pointer
and returns the latest top of heap.
A \syscall{brk} call cannot move the \code{brk} pointer beyond the capacity of the \code{brk} area,
or it will return \code{-ENOMEM} to the application.


\paragraph{Address Space Layout Randomization (ASLR).}


Linux and similar OSes tend to randomize the user address space layout to defeat or confuse remote attacks.
With ASLR, a Linux kernel creates VMAs at unpredictable addresses,
to increase the difficulty for a remote attacker to launch an effective buffer overflow or ROP (return-oriented programming) attack in an application.



\thelibos{} implements ASLR completely in the \libos{}. Although some host OSes may already support ASLR, \thelibos{} enforces another layer of randomization.
When \thelibos{} initializes its VMA list, it also assigns a random factor to the internal function that searches for free regions in the virtual address space.
The randomization will cause \syscall{mmap} to return an unpredictable address, if the application does not specify the address.
\thelibos{} also randomizes the address of the \code{brk} region, within 32MB behind the data segment of the application executable.






