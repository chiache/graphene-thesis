\subsection{Threads}
\label{sec:libos:thread}


A Linux multi-threaded application
is generally programmed with the POSIX threads, or {\bf pthreads}.
%for parallelizing computation on a multi-core machine.
%are commonly used in Linux and similar OSes, for developing multi-thread applications.
The pthread library, or \libpthread{},
is a user-space abstraction layer
which creates schedulable tasks inside a Linux kernel or other OS kernel.
Each pthread maps to a kernel thread,
and \libpthread{} maintains a descriptor (\code{pthread\_t}) of each pthread,
for signaling a pthread or blocking for the termination of a pthread.
Moreover,
\libpthread{}contains several scheduling or synchronization primitives, including mutexes, semaphores, conditional variables, and barriars.
%Few Linux applications may choose an alternative threading library, but no alternatives can avoid creating kernel tasks using \syscall{clone},
%to fully utilize the host CPU resources.


The creation of a pthread in \libpthread{} is based on the \syscall{clone} \linuxapi{}.
When \syscall{clone} is used to create a new thread,
the application or \libpthread{} assigns a preallocated space as the stack of the new thread, and a user function to start the thread execution.
\thelibos{} implement thread creation of \syscall{clone} by calling \palcall{ThreadCreate} in \thehostabi{}.
\palcall{ThreadCreate} will start a new thread from a piece of trampoline code inside \thelibos{}, which switches the stack pointer and jumps to the user function assigned as the starting function.







%For \thelibos{}, supporting a threading library like pthread
%presents two primary challenges.
%The first challenge is the implementation
%of thread-local storage (TLS), a critical, thread-private region for storing the thread states (e.g., a \code{pthread\_t} structure).
%The other challenge is to recreate the OS support
%for many application-level scheduling and synchronization primitives.
%\thelibos{} achieves the latter by implementing majority of the Linux \syscall{futex} API.


For each pthread, \libpthread{} allocates an unique thread-local storage (TLS), which contains a {\bf thread control block (TCB)} and thread-private variables.
A TCB stores the private states of a pthread, including at least a thread identifier.
The definition of a TCB structure is up to the threading library;
\libpthread{} defines the TCB structure of a pthread as \code{pthread\_t},
containing the linked list heads for queuing the pthread
in a ``join'' queue or a wait queue for a synchronization primitive.
On \graphenearch{} Linux, \libpthread{}
locates the TCB of each pthread using using the FS segment register.
The TCB is often
followed by thread-private variables (variables defined with the \code{\_\_thread} keyword) of the application
and libraries,
and both the TCB and thread-private variables
are accessed by directly reading or writing at a specific offset from the FS segment register.
Since accessing FS segment register is a privileged operation,
an application can only set the TCB address
by calling the \syscall{arch\_prctl} \linuxapi{} or passing the address as an argument to \syscall{clone}.
\thelibos{} uses \palcall{SegmentRegisterSet} in the host ABI
to set the FS segment register
in the implementation of \syscall{arch\_prctl} and \syscall{clone}.


Besides creation of pthreads, \libpthread{} contains a collection of synchronization primitives,
including mutexes, semaphores, conditional variables, and barriers.
On Linux, \libpthread{} implements all the synchronization primitives based on one single \syscall{futex} \linuxapi{}.
\syscall{futex} supports various synchronization operations and two primary types of operations are waiting (\code{FUTEX\_WAIT}) and signaling (\code{FUTEX\_WAKE}).
\code{FUTEX\_WAIT}
blocks a thread until another thread updates a memory address
and signals the blocking thread.
\code{FUTEX\_WAKE} then allows a thread
to signal one or multiple threads blocking for the memory update.
\syscall{futex} 
allows atomically checking the state of a critical variable
and switching the current thread to the blocking state if the critical variable is not updated yet.
Using \syscall{futex}, \libpthread{} can implement various types of synchronization primitives;
for example, a two-phase mutex implementation~\fixme{cite the mutex with futex paper}
uses \syscall{futex} to block a thread until an integer variable is set to zero.


To implement \syscall{futex}, \thelibos{} creates a host synchronization event using \palcall{SynchronizationEventCreate} in \thehostabi{}.
Whenever a \syscall{futex} call checks a new word-aligned memory address for blocking, \thelibos{} creates a host event and a wait queue to be mapped to the memory address.
While a waiting \syscall{futex} call blocks on a host event,
another signaling \syscall{futex} call can wake up as many blocking threads in the wait queueue as it wants, using \palcall{EventSet} in \thehostabi{}.


