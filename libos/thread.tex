\subsection{Threading and synchronization}
\label{sec:libos:thread}


A Linux application normally uses POSIX threads, or {\bf pthreads},
for parallelizing computation on a multi-core machine.
%are commonly used in Linux and similar OSes, for developing multi-thread applications.
The pthread library (i.e., \libpthread{}) creates a pthread
by invoking the \syscall{clone} \linuxapi{},
which creates a schedulable task inside the Linux kernel.
The pthread library also maintains a descriptor (\code{pthread\_t}) for signaling or waiting for a pthread from the rest of application.
Finally,
the pthread library contains several scheduling or synchronization primitives,
including mutexes, semaphores, conditional variables,
and barriars.
Few Linux applications may choose an alternative threading library, but no alternatives can avoid creating kernel tasks using \syscall{clone},
to fully utilize the host CPU resources.



\thelibos{} supports creation of pthreads
or other threading primitives
by implementing \syscall{clone} with shared virtual address space. % (no \code{CLONE\_VM} flag).
When creating a new thread, 
\syscall{clone} is usually given a preallocated user stack, a starting function, and an argument to initiate the function.
\thelibos{} implements \syscall{clone} using a \hostapi{}, \palcall{ThreadCreate}, which has similar semantics as \syscall{clone}.


For \thelibos{}, supporting a threading library like pthread
presents two primary challenges.
The first challenge is the implementation
of thread-local storage (TLS), a critical, thread-private region for storing the thread states (e.g., a \code{pthread\_t} structure).
The other challenge is to recreate the OS support
for many application-level scheduling and synchronization primitives.
\thelibos{} achieves the latter by implementing majority of the Linux \syscall{futex} API.



The pthread library allocates a {\bf thread control block (TCB)} for each pthread.
On \graphenearch{} Linux, a pthread %references its own TCB
uses the FS segment register
to reference its own TCB,
followed by the thread-private variables of the application
and user libraries. 
The FS segment register is a privileged context,
and thus an application can only set the address of TCB using the \syscall{arch\_prctl} \linuxapi{}, or pass the address as an argument to \syscall{clone},
unless there is architectural help (an opt-out \graphenearch{} instruction, \assembly{WRFSGSBASE}, allows setting FS/GS registers in the user space).
Therefore, \thelibos{} implements both \syscall{arch\_prctl}
and \syscall{clone} with a \hostapi{}, \palcall{SegmentRegisterSet}, to set the segment register from the host OS or hypervisor.


For each thread, \thelibos{} also maintain an internal TCB,
for storing a pointer to the corresponding thread handle and preserving the register values when \thelibos{} intercepts a \linuxapi{} from \libc{}.
To save the usage of segment registers, \thelibos{} shares the FS register with the pthread library,
by inserting the TCB of \thelibos{} into the pthread TCB.
\thelibos{} copies or recreates its own TCB whenever the pthread library calls \syscall{arch\_prctl} to swap the pthread TCB.



\paragraph{The \syscall{futex} API.}
Most of pthread's synchronization primitives, including mutexes, semaphores, conditional variables, and barriers,
are based on the \syscall{futex} API.
The \syscall{futex} API contains two primary types of operations:
blocking on a specific memory address to be updated, or waking up threads that are currently blocking. % on a specific memory address.
The futex API allows a thread to forfeit the CPU resources
to a progressing thread,
and can be combined with atomic operation
to simultaneously update a critical variable and notify threads that are waiting for the variable to change to certain condition.
\fixme{not finished yet; maybe add a figure to explain how futex is implemented}



