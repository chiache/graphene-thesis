\section{Improving the Hit Rate}
\label{sec:readdir}

The previous sections explain how changes to the structure of the dcache
can lower the average hit latency, through algorithmic improvements.
This section identifies several simple changes that can improve the hit rate.
In the case of a dcache miss, the low-level file system is called to service the system call.
At best, the on-disk metadata format is still in the page cache, but must be translated
to a generic format; at worst, the request blocks on disk I/O.
%In each case, we demonstrate that the additional bookkeeping in the dcache is minimal.
Although not every application heavily exercises these cases with unusually low hit rates,
the evaluation shows several widely-used applications that substantially benefit 
from these optimizations.

%% This section discusses some typical cases in the directory cache of Linux kernels which
%% causes cache misses that are actually avoidable.
%% Based on our case study, these cases of unneeded cache miss
%% are not caused by implementation mistakes,
%% but false obedience to important design principles of caching systems.
%% We observe that these problems are not specific to Linux kernels,
%% but existing in many UNIX operating system kernels.

\subsection{Caching Directory Completeness}

Although the Linux dcache tracks the hierarchical structure of directories, 
it has no notion of whether a directory's contents are completely or partially in the cache.
Suppose Alice creates a new directory {\tt \fnone{}} on a local file system; 
if her next system call attempts to create
file {\tt \fnone{}/\fntwo{}}, the dcache will miss on this lookup and ask the low-level file system if {\tt \fnone{}/\fntwo{}} exists.  
This overhead can be avoided if the VFS tracks that
all directory contents are in the cache.
%This subsection observes a missed opportunity in not tracking %such obvious cases 
%that all 

A second example is {\tt readdir}, which lists the files in a directory,
along with 
their \inode{} number
and their types, such as a regular file, 
character device, directory, or symbolic link.
%Aside from creation of a new directory, the most common way to obtain a complete
%directory listing is through the VFS {\tt readdir} operation.
In the current VFS {\tt readdir} operation, 
the low-level file system is always called, {\em even if the entire directory
is in cache}.
%Readdir returns a listing of the files, both 
For directories too large to list in the user-supplied buffer,
{\tt readdir} may be called multiple times, storing an offset into the directory.
To construct this listing,
the low-level file system must 
reparse and translate the on-disk format,
and may need to read the metadata block from disk into the buffer cache.
As a result,
{\tt readdir} is generally an expensive file system operation,
especially for large directories. % with plenty of files.

%The {\tt readdir} operation is used to implement system calls such as 
%{\tt getdents}, which are called by the c 
%Directory listing ({\tt readdir}) is a frequently used operation implemented
%by file system drivers.
%The operation is often made by system calls {\tt getdents} or {\tt getdents64},
%which are called by the function {\tt readdir} in GNU Library C.


%% We suggest that cost of {\tt readdir} can be reduced by
%% avoiding requesting the file system driver repeatedly to list the same directories.
%% Because most file system drivers implement {\tt readdir} in a stateless way,
%% they must read all related blocks from the disk to construct the result.
%% The cost of {\tt readdir} is primarily dominated by disk IO for
%% reading data blocks and metadata blocks,
%% and interpretion of raw data to retrieve file names, types and inode numbers.

%% File system drivers may individually improve cost of {\tt readdir}
%% by either caching or changing placement of metadata.
%% For example, page cache is general useful in file system drivers
%% to buffer disk IO for retreiving metadata.
%% If related blocks for constructing a directory list is still buffered in memory since the last query,
%% the file system driver does not need to read from the disk again.
%% However, using page cache, the file system driver stil have to
%% interpret raw data from the cached pages
%% to get metadata needed for constructing the {\tt readdir} results.
%% File systems such as DLFS choose to internally cache most recent results of {\tt readdir},
%% so the results can be directly returned when the same directory is listed again.
%% These file system drivers can only maintain very limited size of result caching,
%% because memory management for controlling cache size is out of scope for
%% the implementation of file system drivers.
%% For instance, DLFS can cache only up to one result for each process,
%% which is replaced at the next {\tt readdir}.

We observe that repeatedly listing a directory is a common behavior
in file systems.
For example,
a user or a shell script may repeatedly run the {\tt ls} command
in a directory.
%If {\tt readdir} is called by an application who is confident that the
%directory list will stay static,
%it may avoid repeatedly listing directory by caching the {\tt readdir} results itself.
%However, 
Some applications coordinate state through directory contents,
requiring frequent and repeated directory listings.
For example, {\tt maildir} is a popular email back-end storage format~\cite{maildir},
yielding better performance scalability than the older {\tt mbox} format.
% way for IMAP and POP3 email server to store email message.
Maildir stores each inbox or subfolder as a directory,
and each individual message is a file within the directory.
File names encode attributes including  flags and read/unread status.
%For each mailbox or subfolder that an IMAP server stores in maildir format,
%it maintains several directories where it stores each received mail as a file,
%with file name as a tuple of a unique identifier, the email format version,
%and flags for the mail.
If a message changes state, such as through deletion or being marked as read,
% mail is marked with certain flags,
the IMAP server server will rename or unlink the file, and reread the directory to
sync up the mail list. 
Similarly, a mail delivery agent (MDA), running as a separate process, 
may concurrently write new messages into the directory, requiring the IMAP server
to monitor the directory for changes and  periodically re-read the directory's contents.
%\fixmetsai{eval number here.}


%\fixmedp{We need to implement the lseek restriction}
Our Linux variant caches {\tt readdir} results returned by the low-level file system
in the directory cache.
%Caching of {\tt readdir} results works as follow.
If all of a directory's children are in the cache,
the \dentry{} is marked with a new \completeflag{} flag.
This flag is set upon creation of a new directory ({\tt mkdir}),
or when a series of {\tt readdir} system calls completes without  an {\tt lseek()} on the directory handle
or a concurrent eviction of any children to reclaim space.
% SOSP Space
%We add an additional version number to a directory \dentry{} to track these events:
%the version number is incremented when a directory's child is evicted from cache to save space. 
We note that concurrent file creations or deletions interleaved  with a series of {\tt readdir}s
will still be in the cache and yield correct listing results.
% SOSP Space
%When a directory is opened for read and the \completeflag{} flag is not already set, the version number is 
%recorded in the file handle.  If the version number has not changed 
%when a {\tt readdir} hits the end of the directory, the \completeflag{} is set.
%A seek on the directory handle invalidates the version number.  
After setting the \completeflag{} flag, subsequent {\tt readdir} requests
will be serviced directly from the dentry's child list.
Once a directory enters the complete state, it leaves this state only 
if a child \dentry{} is removed from the cache to reclaim space.

%% When the VFS layer is asked for listing a directory for the first time,
%% it must call {\tt readdir} operation of the file system driver.
%% Once the file system driver returns the results of {\tt readdir},
%% the VFS layer scans the directory list, allocate a \dentry{} for
%% each name that does not exist in the directory cache,
%% and connect it to the target directory's \dentry{} as a child.
%% Once all files in the directory have their \dentries{} under the target directory,
%% the \dentry{} of the target directory is markerd with {\tt LIST\_COMPLETED}.
%% Once the VFS layer needs to list a directory already marked with {\tt LIST\_COMPLETED},
%% it will not call the file system driver, but simply populate the result
%% based on the children of the target directory's \dentry{}.
%% A listed directory will only be invalidated (unmarked)
%% when any of its child \dentry{} is removed for cache shrinking.

One caveat to this approach is that readdir returns part of the
information that would normally appear in an inode, but not enough to
create a complete \inode{}.
For these files or subdirectories, we add \dentries{} without an \inode{} as children of the directory.
These \dentries{} must be separated from negative \dentries{} when they are looked up, and be linked with a proper \inode{}.
%To be able to cache and reuse {\tt readdir} results without inducing additional
%disk reads for each file inode,
%we leverage the \lookupflag{} flag to differentiate between a negative and incomplete \dentry{}.
%The \lookupflag{} flag was only used by btrfs~\cite{btrfs} until Linux
%kernel version 3.3.
%For \dentries{} that already have an inode in memory, there is no need to use this flag;
%similarly, once one of these \dentries{} is looked up, the flag is dropped and a proper \inode{} is linked
%to the \dentry{}.
%\fixmetsai{I think we can leave out the detail. NEED\_LOOKUP bit is removed from 3.3 but in 3.13 they added a MISS\_TYPE flag}
This approach allows {\tt readdir} results to be used for subsequent {\tt lookup}s, cleanly
integrates with existing dcache mechanisms, and gets the most possible
use from every disk I/O without inducing I/O that was not required.

%% If a \dentry{} is created by a file name listed in the {\tt readdir} result,
%% it must become an uninstantiated \dentry{}.
%% It is not practical to instantiate all newly created \dentries{} at {\tt readdir},
%% because it will take a disk lookup for each \dentry{},
%% and cause huge penalty on the performance of {\tt readdir}.
%% As long as the \dentries{} allocated this way are not guaranteed to be accessed soon,
%% it would be better if they are instantiated lazily.
%% A flags in \dentry{} called {\tt NEED\_LOOKUP} is used
%% to mark uninstantiated \dentries{} and force them be instantiated
%% when they are looked up for the first time.


%uninstantiated (not linked with an inode) \dentries{}.
%% The {\tt readdir} results contain enough metadata to create \dentries{} for every file in the directory.
%% An alternative is to keep a separate {\tt readdir} cache in the VFS layer
%% to store raw {\tt readdir} results.
%% We argue that appending {\tt readdir} results into the directory cache
%% has more benefits than caching them separately.
%% Intergration with the directory cache can benefit from the memory management and cache replacement already designed in the current system,
%% and fill up the directory cache faster to speed up any future lookup.
%% Moreover, at creation or deletion of files,
%% if a \dentry{} is added or deleted to a directory listed before,
%% the cached directory list still remains intact, without any need to reconstruct or invalidate the list.

We note that Solaris includes a similar complete directory caching mode~\cite{solarisinternals},
but it is not integrated with readdir or calls other than lookup,
is a separate cache (so the same dentries can be stored twice, and both hash tables must be checked before missing),
and the comments indicate that it only has performance value for large directories.
Our results demonstrate that, when properly integrated into the directory cache,
tracking complete directories has more value than previously thought.

%% SOSP Space
%% Several file systems have used B+ trees or other optimizations
%% to reduce the {\em miss} time for a directory lookup or listing~\cite{ext4, lensing13dlfs}.
%% We demonstrate that simple changes can substantially increase the hit rate.
%% Both optimizations are important, and complementary.


\paragraph{File Creation.}
Directory completeness caching can also avoid compulsory misses on new file creation.
%A side-benefit of caching directory completeness is that it can also answer
%queries for files that do not exist under the directory, even on the first lookup request.
Although negative dentry caching works well for repeated queries for specific files that do not exist,
negative dentries are less effective when an application requests 
{\em different} files that do not exist.
A common example of unpredictable lookups comes from secure temporary file creation utilities~\cite{tmpfiles}.
In our prototype, a miss under a directory with the {\tt DIR\_COMPLETED}
flag is treated as if a negative \dentry{} were found, eliding this compulsory miss.
% SOSP Maybe-cut
In our current implementation, this flag will only be set in a directory that has been read 
or newly created, but other heuristics to detect frequent misses for negative dentries
and to load the directory may also be useful.



%One side-product of caching {\tt readdir} results is to improve cost of file creation
%in a listed directory.
%When a file is open for creation,
%and the correspondent \dentry{} is not found in the directory cache,
%the kernel will request for disk lookup to determine existence of the file before
%calling file system drivers to populate the file on the disk.

%% SOSP Space
%In the current Linux dcache, the first time a path is looked up, the low-level file system will always be called
%(i.e., a compulsory miss).
%Caching directory completeness can reduce the space that would be used for negative dentries 
%and avoid compulsory misses on new file creation.


%The disk lookup before actual on-disk creation is a cost that can be saved
%if the directory is already listed (marked {\tt LIST\_COMPLETED})
%and any names that are not listed are known to be absent on the disk.


%One limitation of this optimization is that the disk lookup before file creation in
%a directory cannot be skipped if the directory is never listed,
%or the listing is invalidated due to cache shrinking.
%Our solution is to use a low-priority housekeeping kernel thread to periodically
%list directories that are known to have frenquent file creation.
%We observe that file creation in a system is often concentrated on a few directories,
%such as the directory {\tt /tmp} for temporary files.


\subsection{Aggressive Negative Caching}

Negative \dentries{} cache the fact that a path does not exist on disk.
%Negative caching can be essential to performance, as applications often lookup file paths
%that may not exist, such as trying to atomically create a lock file, re-creating a temporary file that was just deleted,
%or searching a library load path.
This subsection identifies several 
opportunities for more aggressive use of negative \dentries{},
some of which work in tandem with direct lookup.
%cases where Linux could further leverage 

%% Negative \dentries{} are the \dentries{} associated with file names that are known
%% to be not existing in the storage.
%% The importance of negative \dentries{} is often understimated,
%% but knowing a file to be absent is actually as critical as knowing it to be present.
%% Without allocating negative \dentries{}, the kernel will waste time calling repeated
%% disk lookup for nonexisting file names requested by users.

%% We identify several cases in Linux kernel where negative \dentries{} are not created
%% when the file name is known to be absent.
%% The Linux kernel will only create negative \dentries{} when file system drivers
%% have performed disk lookup and reply that the file or directory is not found.

\paragraph{Renaming and Deletion.}
When a file is renamed or unlinked, the old path can be converted to a negative \dentry{}.
Although Linux does convert a cached, but unused \dentry{} to a negative \dentry{} on unlink,
this is not the case for {\tt rename} and {\tt unlink} of a file that is still in use.
We extend these routines to keep negative \dentries{} after a file is removed, in the case
that the path is reused later, as happens with creation of lock files or Emacs's backup (``tilde'') files.

%% One example of the kernel knowing the absense of a file or directory
%% without disk lookup is the moment
%% when the file or directory is successfully renamed or deleted.
%% When a file is renamed from one file name to another,
%% the kernel can tell that its original name becomes an absent file in the storage.
%% Similarily, when a file is removed, the kernel knows that the its name
%% becomes absent.

%% The Linux kernel never makes any \dentries{} negative at renaming.
%% It is the same at deletion when there are concurrent uses of the deleted \dentries{}
%% and their reference counts are larger than one.
%% In both cases, the kernel cannot directly mark the \dentries{} negative
%% due to the risk that other processes may try to dereference the pointers in the \dentries{}
%% to the inodes.

%% We suggest to allocate new \dentries{} as negative and hashed as the names of files
%% to be renamed or deleted.
%% It is a simple modification to the Linux kernel, but effectively avoid consequential
%% disk lookup for the deleted files.
%% Compare with the overhead for the file system driver to lookup existence of the file in storage,
%% In-memory allocation of negative \dentries{} is a reasonable price.

\paragraph{Pseudo File Systems.}
Pseudo file systems, like {\tt proc}, {\tt sys}, and {\tt dev},
do not create negative \dentries{} for searched, nonexistent paths.
This is a simplification based on the observation that disk I/O will never be involved in a miss.
Because our fastpath is still considerably faster than a miss, negative \dentries{} can be beneficial
even for in-memory file systems,
accelerating lookup of frequently-searched  files that do not exist. 


% design is based on the fact that there is no performance benefit on the slowpath because the existence of paths is determined in memory.
%Using {\em fastpath}, it becomes reasonable to keep naegative \dentries{} even on in-memory file systems 


\paragraph{Deep Negative \Dentries{}.}
\label{sec:readdir:deep}
Finally, we extended the direct lookup fastpath (\S\ref{sec:dcache}) 
with the ability to create ``deep'' negative \dentries{}.
Consider the case where a user tries to open {\tt /\fnone{}/\fntwo{}/\fnthree{}/\fnfour{}},
and {\tt /\fnone{}/\fntwo{}/\fnthree{}} does not exist.
In the slowpath, 
%If a file doesn't exist in the current slowpath, %, top-down lookup path (i.e., the hit {\em slowpath}),
the lookup will fail when it hits the first missing component, and it is sufficient to only cache
a negative \dentry{} for {\tt \fnthree{}}.
Repeated lookups for this path will never hit on the fastpath, however, because there is no entry for 
the full path.

%For instance, if  the lookup will fail on the dentry for {\tt \fnthree{}}.\fixmedp{Right?  Not A?}

In order for this case to use the fastpath, we allow negative \dentries{} to create negative children,
as well as deep children.
In other words, we allow negative \dentry{} {\tt /\fnone{}/\fntwo{}/\fnthree{}} to create children {\tt \fnfour{}} and {\tt \fnfour{}/\fnfive{}},
which can service repeated requests for a non-existent path.
If a file is created for a path that is cached as negative, and the file is not a directory, any negative children are evicted from the cache.

We also create deep negative \dentries{} under regular files to capture lookup failures that return {\tt ENOTDIR} instead of {\tt ENOENT}.
This type of lookup failure happens when a filename is 
use as if it were a directory, and a path underneath is searched.
For example, if {\tt /\fnone{}/\fntwo{}/\fnthree{}} is a regular file, and a user searches for {\tt /\fnone{}/\fntwo{}/\fnthree{}/\fnfour{}}, the Linux kernel will return {\tt ENOTDIR} and never create a negative \dentry{}.
We optimize this case with a deep, {\tt ENOTDIR} \dentry{}.
%Although this type of lookup doesn't cause a cache miss because lookup would stop at {\tt \fnthree{}}, we be further optimize the fastpath using deep negative \dentries{}.
 

%\fixmedp{Worth caching ENOTDIR type errors, or ENOENT only?}

%% When a nonexisting path is checked by the file system driver,
%% a negative dentry is created for the shorter prefix of the path
%% that is absent in the storage,
%% but no negative dentry will be created for other longer prefixes of the path
%% even though they are also known to be absent.
%% Allocating negative \dentries{} that are deeper than the first-level
%% negative \dentries{} is not necessary for component-based lookup
%% because the lookup routine will stop at the first negative \dentry{} it has reached.

%% However, in our {\em fastpath}, deep negative \dentries{} are important for determining
%% absense of deeper paths whose prefixes may be also absent.
%% Without deep negative \dentries{},
%% our {\em fastpath} will always fall back to the {\em slowpath} for these paths,
%% which is a missed oppportunity of optimization.

