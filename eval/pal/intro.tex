The section evaluates the performance of \thehostabi{}.
%on each host.
The performance of \hostapis{} largely depends on the underlying host system interfaces,
such as \syscall{read} as the underlying system call of \palcall{StreamRead}.
%using the \syscall{read} system call,
%and thus introduces a similar latency to the \hostapi{}.
%However, the performance of \thehostabi{} and the underlying host system interface
The translation between \hostapis{} and underlying host system interfaces may introduce overheads,
%to the performance.
depending on the semantic gaps between the two interfaces.
%is unlikely to be equivalent,
%due to the cost of translating between
%the two system interfaces
%when they have different semantics. 
%Additional translation costs
%may cause overheads
\hostapis{} implemented on \sgx{}
suffer more overheads due to
enclave exits and memory encryption costs.
%exiting enclaves for system calls.
%requires redirecting the host system calls
%through enclave calls or hypercalls,
%causing extra overheads.
%Part of the overheads on the \sgx{} PAL
%subject to enclave exits,
%since enclave code cannot invoke system calls directly.
%\sgx{} 
%can suffer memory access overheads,
%especially since the PAL increase the enclave memory footprint.
%The memory access overheads
%results from 
%bringing memory from swap devices into the EPC (enclave page cache)
%or decrypting memory
%at last-level cache misses.
%The latency on the \sgx{} PAL is then mostly dominated by the overheads
%of switching the context between the enclave
%and the untrusted, external PAL using \sgx{} instructions,
%and bringing memory into the EPC (enclave page cache).
% or decrypting memory on a last-level cache miss.
This section
evaluates the overheads of host system interface translation
by comparing the performance of \hostapis{}
with similar system interfaces on native Linux.


%In theory, the definition of \thehostabi{}
%is meant to minimize the translation cost to most host system interfaces,
%by adopting similar, UNIX-like semantics.
%%Since most \hostapis{} are just wrappers
%%of the underlying system calls,
%%the translation cost is mostly reduced to simply replacing the generic identifiers and control flags
%%to the semantics that are recognized by the host OS.
%A major cost
%in translation is to parse a URI (unified resource identifier)
%for determining the file path or network address
%%and compose a equivalent file system path or network address
%to request host OS services.
%%The second factor is the translation cost
%%of the \hostapis{}.
%%For portability, \thehostabi{} is defined with generic semantics, without host-specific notions
%%such as process identifiers, file descriptors,
%%file system paths,
%%and system call flags.
%%The PAL must translate the arguments of \hostapis{}, including PAL handles, URIs (Uniform Resource Identifiers), and generic flags,
%%to the arguments interpretable by the host kernel.
%Other translation costs,
%such as converting optional flags,
%are relatively marginal, compared with the overall latency of a \hostapi{}.
%%because the translation is mostly straightforward,
%%and only requires simply logics
%%and little memory copy.
%%Without extra security checks,
%%a \hostapi{} is more likely to suffer high overheads if the implementation
%%requires additional system calls for complementary operations
%%to the base abstraction,
%%or constantly retrying a system calls at failures.



For a few \hostapis{} %a majority of overheads
%result from
security checks or enforcements
impact the performance
%cause overheads
%for protecting applications
under a specific host threat model.
%for ensuring the safety of running an application
%within the threat model
%of a host.
%Finally, the third factor that impacts the PAL call efficiency
%is the cost of security checks,
%either inside the host kernel or the guest.
%The cost of security checks varies between hosts, and is correlated with the presumed security models.
%The threat model for 
\graphene{}
isolates
%generally
mutually-untrusting applications from attacking the host OS or each other, % through host system interfaces,
%the security checks mainly
by restricting the attack surface through host resources sharing and unnecessary system calls.
%using both the reference monitor and \seccomp{} filter.
\graphenesgx{} assumes a even stronger threat model,
which does not trust any OSes, hypervisors and off-chip hardwares.
Security checks for \sgx{}
need to
validate potentially-malicious inputs
%protects the application and \libos{} against malicious inputs
from the untrusted OS,
%and thus focus on validating the results of system calls,
%using either cryptographic techniques or semantic checks.
%Cryptographic techniques are used to: (1) validate the file against the secure hash, at \palcall{StreamOpen}, (2) check the file chunks against a Merkle tree of hash values, at \palcall{StreamRead}, and (3) establish a TLS connection over inter-enclave RPC, at \palcall{ProcessCreate}.
including the cryptographic efforts
%operations
%tend to contribute a major portion of overheads
%to the SGX PAL,
of encrypting and authenticating file contents or RPC streams.
%in a file or over a RPC stream.
%especially for \hostapis{} that externalize data to the untrusted OS, such as file and network operations.
%may be dominated
%by security checks,
%especially the ones based on cryptographic operations.
%on large chunks of data exported to the untrusted OS.


The evaluation is based on \lmbench{} 2.5~\cite{McVoy:lmbench}.
For each \hostapi{}, the evaluation %shows the breakdowns
%of its latency or throughput,
compares among the Linux and SGX PALs,
%both with and without the security mechanisms, such as the
both with and without %
security mechanisms,
%\seccomp{} filter and reference monitor,
% on the Linux PAL,
and a native Linux kernel,
to measure the overheads of PAL implementations.
%as well as testing under different
%implementation strategies.
%The evaluation focuses on \hostapis{} that are especially sensitive for the performance of the \graphene{} \libos{}.


% the efficiency of \hostapis{} on both Linux and \sgx{} hosts, and shows the impact of each performance factor.
%The evaluation is based on micro-benchmark programs similar to \lmbench{} 2.5~\cite{McVoy:lmbench},
%and is compared against
%similar system calls on Linux.


















