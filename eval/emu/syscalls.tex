\subsection{Single-process system calls}
\label{eval:perf:syscalls}


%In order to understand the overheads of individual system calls,
Table~\ref{tab:eval:lmbench-syscalls} lists 
a representative sample of 
tests from \lmbench{} 2.5 benchmark suite~\cite{McVoy:lmbench}
(extended with additional experiments).
Each row reports a mean and 95\% confidence interval,
assuming the benchmark results are normally distributed;
to improve the precision,
the number of iterations in each test is increased to at least a thousand times, which effectively lower the variance
in most tests.
Although assuming a normal distribution may not be realistic for most benchmark results,
the error is likely to be marginal with the very low variance
observed in the tests.
%we use the default number of iterations for each test case.
%We have added code to \lmbench{} to also calculate 95\% confidence intervals 
%within a run~\footnote{The lmbench authors deliberately exclude variation statistics
%because most methods assume a known distribution, generally a normal distribution---an 
%assumption which is often not the case for a computer microbenchmark~\cite{staelin05lmbench}.
%Though confidence intervals should be taken with a grain of salt, 
%we include them because they clearly indicate that these experiments have very low variance. In 
%a few cases of minor performance improvement, one can assess the impact of noise.}.
Besides, to measure the marginal cost of the \seccomp{} filter and reference monitor on a Linux host,
the experiments include the cases both with
and without the \seccomp{} filter and reference monitor.


The evaluation results categorize
the system calls emulated inside \thelibos{}
as two types.
The first type of system calls is completely serviced inside \thelibos{};
the evaluation results show that these system calls are even faster than native, because \thelibos{} does not switch context into the kernal space
to service the system calls.
For instance,
a null system call (i.e., \syscall{getppid}) and installing a signal handler with \syscall{sigaction}
are up to three time as fast as the native performance.
The second type of system call requires translation to a native host system calls.
%For instance, 
%the self-signaling test (sig overhead)
%just calls the signal handler as a function,
%which is almost twice as fast
%as the Linux kernel implementation.

\begin{table}[htp!]
\input{tables/lmbench-syscalls}
\caption{System call benchmark results based on \lmbench{} 2.5. Comparison is among (1) native Linux processes, (2) \graphene{} \picoprocs{} on Linux host, both without and with JIT-optimized SECCOMP filter ({\bf +SC}) and reference monitor ({\bf +RM}), and (3) \graphene{} in SGX enclaves.
System call latency is in microseconds, and lower is better.
System call bandwidth and throughput are in megabytes per second and operations per second, respectively, and higher is better. 
%The file system is measured in thousands operations per second, and higher is better.
Overheads are relative to Linux \linuxversion{}; negative overheads indicate improved performance.} 
\label{tab:eval:lmbench-syscalls}
\end{table}


