\section{Host ABI compatibility}
\label{sec:overview:host}

A host ABI (application binary interface) defines the convention of application binaries, including the binary format and the linking procedure, as well as a set of  system interfaces.
The host ABI describes the minimal functionality that a host OS has to implement, in order to reuse an application and the supporting libraries, including the \graphene{} library OS. The host ABI is both simple (minimizing the effort of porting per host) and sufficient (containing enough host abstractions for implementing the library OS functionality).


The host ABI defines the acceptable binary format as a simplified version of the ELF (Excutable and Linkable Format).
Each host of \graphene{} is supposed implement a minimal dynamic loader,
which can load the \graphene{} library OS binary in ELF.
The library OS then provides the full-functioned dynamic loader,
which will loads and links the rest of application binaries, just like the native Linux loader (i.e., \code{ld.so}).




\subsection{Host abstractions}
\label{sec:overview:host:abstractions}


The host ABI shares several common abstractions with production OSes. The interfaces, as part of the host ABI, which access these host abstractions, are ultimately simplified to reduce the porting effort on each host.
Unlike the system interfaces in the OS, the host ABI does not prioritize backward compatibility. Therefore, the host ABI includes only the minimum interfaces that the library OS needs to interact with the host. The host ABI does not have to include any of  the legacy system interfaces from a production OS, let alone preserving different flavors of system interfaces for backward compatibility.


The host ABI inherits partially the high-level semantics of another host ABI defined by a prior work called \drawbridge{}~\cite{porter11drawbridge}.
\drawbridge{} is a library OS for reusing single-process Windows applications,
in a lightweight, guest environment.
The definition of the \drawbridge{} host ABI is a hint, for creating a list of host abstractions necessary for the library OS, including as streams, memory, threads, and processes. The host ABI is also complemented with several Linux-specific abstractions, such as exception handing and the control of segment registers (i.e., \code{FS}/\code{GS} registers).
The host ABI eventually contains \palcalls{} host functions (Table~\ref{tab:overview:abi}), which can be directly called from the library OS. \graphene{} shows that the host ABI is sufficient to implementing a large portion of the Linux system calls.


\begin{table}[t!]
\centering
\input{abi}
\caption{Overview of the \graphene{} host abstractions. The abstractions marked with the symbol $\dagger$ are introduced in \graphene{}. The rest abstractions are inherited and extended from \drawbridge{}.}
\label{tab:overview:abi}
\end{table}


The host ABI also implements two types of remote procedure call (RPC) primitives.
\funcname{StreamSendHandle} and \funcname{StreamRecvHandle}
allow delegation of an open stream handles to another process, through a connecting pipe. The feature is similar to sending file descriptors through UNIX sockets in Linux, and is used to share opened network sockets with the \syscall{fork}'ed processes.
Another RPC abstraction is a bulk IPC channel; a process can use \funcname{PhsyicalMemoryCommit} to commit a large chunk of memory to a bulk IPC channel, which \funcname{PhsyicalMemoryMap} can map into another process, as copy-on-write. The library OS uses bulk IPC as an optimization to \syscall{fork}.


To simplify isolation, the functions to access each host abstraction must appear stateless to the host, except for the handles to identify the resources. Each call to the host functions is independent. The arguments given for each call must be always be absolute values, instead of relative values.
For example, the offset given to \funcname{StreamMap}, \funcname{StreamRead}, and \funcname{StreamWrite} (if the opened handle is a file) are offsets from the beginning of the file, and thus are irrelevant to how many bytes that are previously written or read.
When enforcing isolation rules, the host OS can check the arguments of each calls to the host functions, independently and atomically.

\subsection{Porting the host ABI}
\label{sec:overview:host:port}


The compatibility of \graphene{} relies on each host implementing the host ABI.
The host ABI is defined for the simplicity of porting.
First of all, the number of abstractions included in the host ABI
is objectively smaller than the number of system interfaces in a production OS (e.g., system calls in Linux). 
The simplicity of porting the host ABI is experiment by the development of
several ``classic'' ports, including the ports to Windows, Linux, OS X, \fixme{the last two are prospective} the L4 microkernel, and Barrelfish.
For each port, the amount of code written for implementing the host ABI is at the order of magnitude of thousands of lines of code, which is much more manageable than implementing a flat translation layer for system interfaces.


For each port of the host ABI, the OS developers implement a thin translation layer,
or platform translation layer (PAL). The PAL must translate the host abstractions, to the system interface native to the target host. 
The PAL must also be a dynamic loader, which implements the minimal loading feature included in the host ABI.
For a host OS that does not support ELF binaries, the PAL must follow the binary format which the host OS accepts, such as the Portable Executable (PE) format on Windows.
The PAL is the only layer in the user space which cannot be reused
across different hosts. Besides the PAL, all of the other binaries in the user space are fully reusable, including the library OS, the supporting libraries, and the application executable.



The host abstractions map to several system interfaces in production OSes.
For example, \funcname{StreamRead} and \funcname{StreamWrite} can directly map to the POSIX functions \funcname{pread} and \funcname{pwrite}, which are available in most OSes including Linux, BSD, OS X, and Windows.
More than half of the functions in the host ABI can be counted toward this category.
The rest of the host abstractions are either specific to Linux
(e.g., TLS support),
or belong to the POSIX functions that are not shared by all production OSes
(e.g., \funcname{mmap} on Windows).
The PAL emulates these host abstractions, using existing system interfaces available on the host OS, unless the software emulation is fundamentally impossible (e.g., restricted by the system interfaces), or too expensive (e.g., high overhead from copying data).





\subsection{Security isolation}
\label{sec:overview:host:security}


The security isolation of \graphene{} ensures that mutually distrusting applications cannot interfere with each other. The mechanism of isolation is comparable to running each applications in separate virtual machines.
To ensure isolation, each host must restrict access from the applications or the library OS, to any unauthorized host abstractions.
On most hosts, a reference monitor in the host kernel can enforce the access control on the host system interfaces, files, network addresses, and RPC streams.
The only exception is the Intel SGX platform; in SGX, not only applications distrust each other, an application also assume the host kernel to be untrustworthy.
In this case, an application running inside an enclave must enforce isolation internally using software techniques (e.g., encryption).


%\graphene{} reduces the attack surface exposed to applications
%by restricting access to the host kernel ABI 
%and prevents access to unauthorized system calls, files, byte streams,
%and network addresses with a \emph{reference monitor}.
%The host kernel ABI exported by the \pal{} heavily 
%limits the ability of a \graphene{} application to interact with the rest of the system;
%any external interactions are further mediated by a reference monitor.
%Unlike a typical Linux system, \graphene{} applications cannot interact with shared 
%system daemons or other shared system resources.
%As a result, \graphene{} enforces security isolation similar to running applications in separate VMs---even
%applications that span multiple processes.
\graphene{} contributes a multi-process security model 
based on the abstraction of a \emph{sandbox},
or a set of mutually trusting processes.
If a reference monitor exists, the reference monitor permits the processes within the same sandbox to communicate and exchange RPC messages, but disallows cross-sandbox communication.
The current work focuses on all-or-nothing security isolation, although we expect
this design could support
controlled communication among mutually distrusting \liboses{}
in future work.

The only host abstractions that are shared across processes and must be mediated by the host for isolation are files, network sockets, and RPC streams
--- all other allowed host ABI modify only local process state, such as VMAs and threads.
%Thus, the reference monitor need only mediate file access, socket and RPC stream creation.
%an unprivileged daemon
%as well as extensions to the App\-Armor LSM~\cite{apparmor},
%which checks file and socket policies in the kernel.
%, reducing context switching overhead
%and the risk of race conditions~\cite{garfinkel03traps}.
In order for the reference monitor to restrict file access, socket and RPC stream creation,
each application includes a \emph{manifest file}~\cite{hunt07rethink},
which describes a {\tt chroot}-like, restricted view of the local 
file system (similar to Plan 9's unioned file system views~\cite{pike90plan9}),
%including read-only shared files,
as well as \emph{iptables}-style~\cite{iptablesman} network firewall rules.
To facilitate sharing read-only libraries, a manifest may specify a file system view which combines several different sub-directories of the local file system, and can prevent writing to files or directories.


For example, the \graphene{} reference monitor on the Linux host is implemented using \syscall{ioctl} to a special device \fixme{a prospective design}\code{/dev/graphene}.
A process is restricted by the Linux SECCOMP filter~\cite{seccomp}, to use any \syscall{open}, or \syscall{connect} and \syscall{bind} to sockets.
It must use the \graphene{} special device to open or create streams, so the file paths or network addresses can be checked against the sandbox rules. The kernel module as the driver of the \graphene{} special device can coexist with any Linux Security Module (LSM), such as \emph{AppArmor} or \emph{SELinux}.


When a new process is launched by the host, it begins execution in a new sandbox.  
Child processes may either inherit their parent's sandbox, or can be started in a separate sandbox---specified by a flag to the host abstractions of process creation.
A parent may specify a subset of its own file system view 
when creating a child, but may not request access to new regions of the host file system. 
%The restrictive policy enforced on the child will be written in a new manifest file generated by the parent, and the policy will be checked by the reference monitor.
The child may also issue an {\tt ioctl} call to 
dynamically detach from the parent's sandbox. The reference monitor prevents byte stream creation across sandboxes.
%among picoprocesses
%that are not in the same sandbox.
%and restricts external connections to remote URIs according to firewall rules in the manifest.
When a process detaches from a sandbox, effectively splitting the sandbox, the host must closes all RPC streams that could bridge the two sandboxes.

\paragraph{Threat model.}
On a host with a reference monitor, the host OS and the reference monitor are both trusted, to mediate all system interfaces used to implement the host ABI. The host must check all access to any abstractions with effects outside of a process's internal state, such as an opened file, or a connected network socket.
Processes inside the same sandbox mutually trust each other. The adversary can run arbitrary code inside of one or more processes within one or more sandboxes.
The adversary can control all code in its processes, including the library OS and the host-specific PAL.
%{\tt libLinux} and the \pal{}. 
%We also assume a trusted reference monitor process running on the host kernel that 
%launches \graphene{} applications and mediates all system calls with external effects,\fixmedp{define precisely}

%\graphene{} ensures that %The key security property the \graphene{} design upholds is that 
%the adversary cannot interfere with any victim picoprocesses
%in a separate sandbox.  
%The \graphene{} sandbox design ensures strict isolation: 
%if the only shared kernel abstractions are byte streams and files, 
%and the reference monitor ensures
%there is no writable intersection between sandboxes,
%the adversary cannot interfere with any victim picoprocess.


%%% The only processes allowed to run as standard kernel processes (non-\graphene{}) 
%%% are the reference monitor and
%%% system administration utilities that need more kernel interfaces than the \pal{} ABI provides.
%%% Ensuring that a collaborating picoprocess correctly implements
%%% some function (such as receiving a signal),
%%% as well as preventing exploitation of vulnerabilities in picoprocesses
%%% are beyond the scope of this work.

%\graphene{} reduces the system attack surface of the host, but does not change the size of its
%trusted computing base; however, reducing the effective system call table
%size of a picoprocess does facilitate adoption of a smaller host kernel,
%which we leave for future work.

