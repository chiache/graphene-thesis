\section{The Host ABI}
\label{sec:overview:host}


\graphene{} achieves compatibility by determining which OS features
are essential to the reuse of applications, and defining a host ABI as a new boundary between OSes (or hypervisors) and applications.
The role of the host ABI is to decouple the low-level OS functionality, such as abstracting hardware resources and operations, from reproducing the idiosyncrasy of system interfaces. 
%OS developers only have to port the host ABI for an OS which needs a boost of compatibility.
All the system interface implementation is absorbed
into a para-virtualized library OS,
using the host ABI to interact with the OSes and hardware designs
lacking compatibility.
The host ABI prevents OS developers
from repeating the painful process of reproducing system interfaces,
and reuses both applications and the library OS implementation with more manageable effort.


 






The porting of the host ABI is specific to each ``host''. We define a host as an OS or a hypervisor which exports a consistent interface to applications or virtual machines.
An OS kernel, such as Linux, BSD, or Windows, can be treated as a host, upon any physical machines where the kernel can run the applications.
If an OS has mutated or tweaked the interface for a hardware platform,
such as an SGX enclave 
running on an untrusted Linux kernel,
the combination of the OS (Linux) and the hardware platform (SGX) is considered a specialized host.
The Linux-SGX port of the host ABI faces several unique challenges,
which will be further discussed in Chapter~\ref{chap:sgx}.


\begin{comment}
%\fixme{each sentense should be a paragraph; starting the 2nd sentence}
\fixmedp{start with a strong opening stating the rationale}
The host ABI of \graphene{}
define functions needed from a host, in order to implement the library OS for reusing applications.
%to reuse an application and all its supporting libraries, including the \graphene{} library OS.
Each host of \graphene{} contains an OS and a hardware platform, either of which causes compatibility issues for running unmodified applications.
OS developers can port the library OS to a new host,
by simply reimplementing the narrowed host ABIs using abstractions available on the host.
%a new host platform.
%For each host which requires the compatibility for unmodified Linux applications, one only has to implement the narrowed host ABIs,
%instead of reimplementing the bloated, ``legacy'' system interfaces
%needed by the applications.
By implementing the host ABI, OS developers skip the painful process of rebuilding the whole system interfaces of a commercial OS such as Linux.
The host ABIs strictly decouples the porting effort on the hosts from the compatibility feature for applications.
%The host ABIs decouple the OS development in the host and the implementation of compatibility for the existing Linux application.
What the host ABI exposes is a simplified extended machine,
similar to a para-virtualization interface, capable of running the library OS as a lightweight virtual machine. % with compatibility against Linux applications.
%on which another layer of virtualization (i.e., the library OS) can be built to reproduce the compatibility for Linux.
\end{comment}


\begin{comment}
Two design principles drive the definition of the host ABIs:
{\em simplicity} (i.e., easy to port on any hosts)
and {\em sufficiency} (i.e., containing enough OS functions for implementing a library OS).
The process of deciding the host ABIs is comparable to
finding a ``pinch point'' within a OS implementation,
which can conveniently mediate a significant portion of OS execution paths for managing hardware abstractions.
%The two principles drive the development of the host ABIs,
%The whole development of the \graphene{} library
%must be disciplined
%on extending the host ABIs only when it is strongly required.
%of restraining extensions to the host ABIs unless absolutely necessary.
The two principles
determine the soundness of the \graphene{} approach to improving compatibility
for any hosts.
\end{comment}


\paragraph{Simplicity of the host ABI.}
To reduce the burden of OS developers, the host ABI is designed to be simple enough to implement, on any targeted hosts.
The simplicity of implementation is subjective and depends on the hosts,
but can be improved based on two primary approaches.
The first is to ensure the narrowness of the host ABI, as reducing the amount of functions and corner cases included in the definition.
Although the narrowness does not directly indicate simplicity of porting, it is always beneficial to remove redundant OS functions or corner cases,
to save the porting effort.
The development of \graphene{} keeps the narrowness of the host ABI, by disciplinarily avoiding adding any functions,
except the cases when the library OS fails to implement certain system calls,
or suffers significant performance overheads.

Another approach is to define functions which can be mapped to native system interfaces on the hosts with similar functionality.
%the likelihood of finding similar features on the host, to be translated to functions in the host ABI.
An observation of OS development is that
%similarity of system interfaces is common among most OSes.
many OSes export similar system interfaces, to shorten the learning curve for programming applications.
We can find lookalike functions in many hosts, such as \syscall{read} in Linux, BSD, and POSIX, and \syscall{ReadFile} in Windows (for regular files).
The definition of the host ABI
is based on observations of various host system interfaces,
including Linux system calls and Windows API.
%exported by the targeted hosts,
%and defines the functions in the host ABI, to be easily translated to the native system interfaces.
%The host ABI is essentially a subset of the common features from every potential hosts.
We expect most of the host ABI are straightforward to port on most OSes,
as most functions in the host ABI can be easily translated from the host system interfaces.

%For example, the host ABI defines \syscall{StreamRead} and \syscall{StreamWrite} for accessing I/O streams, similar to .
%xcept some nuanced details like order of parameters.


% by including OS functions , such as \syscall{FileRead} and \syscall{FileWrite}, similar to the Linux system calls, \syscall{pread} and \syscall{pwrite}.




\begin{comment}
The simplicity of the host ABIs requires retaining a minimalist design of host functions. %, based on typical OS services for managing hardware.
%\graphene{} reduces the host functions
%to the bare minimum.
The host ABIs should only contain operations that
are absolutely necessary for requesting external hardware abstractions.
%A way to simplify the host ABIs is to move host functions into the library OS
%and to replace them with wrappers consisting of other host functions.
Any functions that can be partially or wholly implemented inside the library OS
should be further simplified, or even removed from the host ABIs.
%---in other words, whether the host ABIs can be further reduced.
Moreover, the host ABIs have to be simple enough to implement on
most hosts;
%In the simplest host ABIs, none of the host functions shall be able to internally implement the behavior of another host function,
%or the definition of the host ABIs is further reducible.
that is, the host ABIs should contain only OS functions that are commonly offered on
most hosts.
The host ABIs are close to simplified UNIX interfaces,
such as reading or writing a file or an I/O device as a byte stream,
or creating a virtual memory mapping.
%the most common OS functions
%offered on most of the potential hosts,
For most hosts,
implementing the host ABI should be as straightforward as redirecting the functions to the closest host system calls.
%such as the Linux system calls or the Windows APIs.
For example, the functionality of \syscall{StreamRead} and \syscall{StreamWrite} in the host ABIs can loosely match with
\syscall{read} and \syscall{write} in Linux,
or \syscall{ReadFile} and \syscall{WriteFile} in Windows.
%This thesis also evaluates the simplicity of the host ABIs by counting the lines of code used to implement the host ABIs on each host platforms.
Since most OSes have inherited a similar design from UNIX,
it is fair to assume finding
comparable OS functions %host platforms
to the host ABI would be reasonably easy.
%fair to assume that the host ABIs 
\end{comment}



\paragraph{Sufficiency of the host ABI.}
The host ABI is responsible for exporting sufficient functionality to the library OS,
for requesting hardware or OS abstractions which cannot be implemented in user space.



For sufficiency, the definition of the host ABI
%are demonstrated by the fact that
%the exported host functions 
intends to cover every categories of typical functions in an OS.
%and a full-function library OS is implemented on top of them.
In general, there are five categories of typical OS functions,
%can be categorized into five types:
including
process, memory, I/O, files, network, security and protection~\cite{dhamdhere2007os-textbook}.
Besides security and protection,
the definition of the host ABI is closely related with hardware management,
and offers the most basic abstractions for each category of OS functions.
%managing specific types of hardware,
%and each contain a few basic abstractions
%which can be expanded into other system interfaces.
For example, the basic OS functions for memory management include
allocating (\syscall{VirtMemAlloc}),
protecting (\syscall{VirtMemProt}),
and deallocating (\syscall{VirtMemFree}) memory regions. % at certain granularity
%(usually in pages).
These basic functions can be used to implement other forms of memory allocation,
such as growing heaps with \syscall{brk}
or allocating thread-private stacks.
%The definition of the \drawbridge{} host ABI is a hint, for creating a list of host abstractions necessary for the library OS, including streams, memory, threads, and processes. 
%If the host ABIs are insufficient for implementing certain system interfaces, one may extend the host ABIs with the missing functions,
%with the discipline to retain the simplicity of the host ABIs.
%The extension to the host ABIs must be d, to keep the extension minimal, and to avoid adding redundant functions.
The implementation of the \graphene{} library OS demonstrates that
the host ABI is sufficient for implementing a significant portion of Linux system calls.

A major part of 
the host ABI is inherited from a prior work called \drawbridge{}~\cite{porter11drawbridge}, but not exactly verbatim.
\drawbridge{} is a library OS for running single-process Windows applications
in a lightweight, guest environment.
\drawbridge{} demonstrates that its host ABI is sufficient
for running a library OS in which 99.7\% of code comes from the Windows 7 source.
The host ABIs of \drawbridge{} are later extended
for running a Linux-based library OS called Bascule~\cite{baumann13bascule}.
Both the \drawbridge{} and Bascule host ABIs have been
ported to multiple hosts, including Windows, Linux, Barrelfish, and Intel SGX~\cite{porter11drawbridge,baumann14haven,mssql-on-linux,baumann13bascule}.
%ill loads and links the rest of application binaries, just like the native Linux loader (i.e., \code{ld.so}).
\graphene{} takes the high-level definitions of the \drawbridge{} and Bascule host ABIs, and customizes for general-purpose Linux applications and a wider range of hosts. 




\subsection{Definition of host functions}
\label{sec:overview:host:functions}


%\fixmedp{the beginning doesn't capture the whole paragraph.}
%The host ABI shares several common abstractions with production OSes.
The host functions of \graphene{}
include a set of basic abstractions from the typical OS functions of an OS.
The definition of the host functions
should be unsurprising to average OS developers,
making the implementation on a new host to be fairly straightforward.
The host functions reflect the common OS abstractions defined in most mainstream OSes, such as Linux and Windows.
Although the same OS abstractions may be defined
as different idiosyncratic system interfaces on each host OSes,
\graphene{} takes into consideration of porting the host functions to either OSes, in the most effortless way possible.




%fixmedp{give more of the background}
Table~\ref{tab:overview:abi} lists the \palcalls{} functions defined in the \graphene{} host ABI.
27 functions are inherited
from high-level definition of the \drawbridge{} host ABI,
including functions to managing I/O streaming (e.g., \syscall{StreamOpen}), memory allocation (e.g., \syscall{VirtMemAlloc}), scheduling processes and threads (e.g., \syscall{ThreadCreate}), and several miscellaneous functions (e.g., \syscall{ThreadCreate}).
Most of the host functions only affect the OS or hardware states
related to the process itself.
For example, \syscall{VirtMemAlloc} can only allocate memory in the calling process,
and cannot affect other processes running in parallel.
Only I/O streaming functions export states to the host OS, and share states with other processes or library OSes.



Only 8 functions are specifically extended for \graphene{}, in order to implement OS abstractions that are unique to Linux.
The Linux abstractions include
%The host ABI is also complemented with several Linux-specific abstractions, such as
handing hardware exceptions delivered as signals,
and controlling 
x86-specific segment registers (i.e., \code{FS}/\code{GS} registers)
for supporting thread-local storage (TLS).
%The host ABI contains host functions (), which can be directly called from the library OS. \graphene{} shows that the host ABI is sufficient to implementing a large portion of the Linux system calls.
%These functions are not defined in \drawbridge{}, the Windows-based library OS,
%because these abstractions do not exist in Windows.
The \drawbridge{} host ABI does not contain exception delivery because the feature is
not commonly used in Windows applications.
Moreover, the x86 segment registers cannot be modified in Windows
because the OS assigns fixed values to these registers
for the whole execution.
Although \drawbridge{} excludes these abstractions, Bascule extends the host ABI to include similar functions,
demonstrating that the extension is indeed necessary.




\begin{table}[htp!]
\centering
\input{abi-table}
\caption{Overview of functions in the \graphene{} host ABI. The abstractions marked with the symbol $\dagger$ are introduced in the initial publication of \graphene{}~\cite{tsai14graphene} or later extended for this thesis, whereas the rest are inherited from \drawbridge{}~\cite{porter11drawbridge}.}
\label{tab:overview:abi}
\end{table}

%The interfaces, as part of the host ABI, which access these host abstractions, are ultimately simplified to reduce the porting effort on each host.
%Unlike the system interfaces in the OS, the host ABI does not prioritize backward compatibility. Therefore, the host ABI includes only the minimum interfaces that the library OS needs to interact with the host. The host ABI does not have to include any of  the legacy system interfaces from a production OS, let alone preserving different flavors of system interfaces for backward compatibility.



Beside the Linux-specific extension,
the host functions also include two optional primitives for remote procedure call (RPC).
RPC is critical for implementing the coordination of OS states
across library OS instances.
The basic form of RPC in \graphene{} is a pipe-like RPC byte stream, which a library OS can simply use to send messages.
It is a common design choice
to implement inter-process coordination through message-passing
instead of shared memory, especially for hardware platforms that do not guarantee memory coherence~\cite{baumann09barrelfish}.
A problem to the message-passing approach is the significant overheads
on frequently exchanging distributed OS states.
As an optimization, \graphene{} defines a bulk IPC mechanism
as optional host functions,
for host platforms that urgently require lowering the RPC overheads.
Another extension is for
%\funcname{StreamSendHandle} and \funcname{StreamRecvHandle}
delegating opened stream handles to another process, through a connecting pipe.
The feature is similar to sending file descriptors
through UNIX sockets in Linux, and is used to share opened network sockets with the \syscall{fork}'ed processes.
%Another RPC abstraction is a bulk IPC channel; a process can use \funcname{PhsyicalMemoryCommit} to commit a large chunk of memory to a bulk IPC channel, which \funcname{PhsyicalMemoryMap} can map into another process, as copy-on-write. The library OS uses bulk IPC as an optimization to \syscall{fork}.
Despite that either of the RPC primitives
is not necessary easy to implement on every hosts, the inclusion of these host functions is completely optional, and the library OS can always fall back to the message-passing approach.



All the host functions are designed to appear as ``stateless''
as possible to the library OS.
Being stateless to the library OS means that
a host function does not preserve any permanent state of certain host abstraction.
A stateless function can recover
from disconnection of the library OS, and be reconnected at any timing.
The host functions can maintain temporary bookkeeping for the convenience of porting,
but should not assume the bookkeeping states to be permanent.
The principle of defining all the host functions to be stateless
is primarily for two purposes:
{\em migration} and {\em security isolation}.
For migration, the fact that the library OS can disconnect freely from the host functions simplifies the implementation of the migration feature.
Migration is also an important foundation to implementing \syscall{fork}, because the cloned process need to receive a snapshot of the parent process.
For security isolation, 
a stateless host function is easier to check,
because the security monitor only has to verify each instance of host function calls,
instead of tracing multiple host functions over a longer period of time.

%the functions to access each host abstraction must appear \fixmedp{clarify `stateless'} stateless to the host, except for the handles to identify the resources. Each call to the host functions is independent. The arguments given for each call must be always be absolute values, instead of relative values.
%For example, the offset given to \funcname{StreamMap}, \funcname{StreamRead}, and \funcname{StreamWrite} (if the opened handle is a file) are offsets from the beginning of the file, and thus are irrelevant to how many bytes that are previously written or read.
%When enforcing isolation rules, the host OS can check the arguments of each calls to the host functions, independently and atomically.


%A host ABI (application binary interface) has to define the convention of application binaries, including the binary format and the linking procedure, as well as a set of  system interfaces.
%The host ABIs contain a minimal loader which recognizes a basic version of the ELF (Executable and Linkable Format), just enough to compose a binary of the library OS.
%The very initial loading procedure as part of the host ABIs only loads a clean library OS instance.
%Each host of \graphene{} is supposed implement a minimal dynamic loader,
%which can load the \graphene{} library OS binary in ELF.
%The library OS then completes the dynamic loading procedure,
%by directly loading the Linux native dynamic loader (i.e., \code{ld.so}), and indirectly loading the rest of the application binaries.



\subsection{Porting to different hosts}
\label{sec:overview:host:porting}


The compatibility of \graphene{} relies on each host to implement the host ABI.
The host ABI is defined for the simplicity of porting, as well as the sufficiency for implementing a library OS compatible to Linux.
First of all, the number of host functions included in the host ABI
is much smaller than the number of system calls in a commodity OS such as Linux. 
The portability of the host ABI is experimented by
the development of
several ``classic'' \graphene{} ports, including Windows, Linux, OS X,
\fixme{the last two are prospective}
the L4 microkernel, and Barrelfish.
For each port, the amount of code written for implementing the host ABI is at the order of magnitude of thousands of lines of code, which is much more manageable than implementing a flat translation layer for system interfaces.


For each port of the host ABI, the OS developers implement a thin translation layer,
or platform translation layer (PAL). The PAL must translate the host abstractions, to the system interface native to the target host. 
The PAL must also be a dynamic loader, which implements the minimal loading feature included in the host ABI.
For a host OS that does not support ELF binaries, the PAL must follow the binary format which the host OS accepts, such as the Portable Executable (PE) format on Windows.
The PAL is the only layer in the user space which cannot be reused
across different hosts. Besides the PAL, all of the other binaries in the user space are fully reusable, including the library OS, the supporting libraries, and the application executable.



The host abstractions map to several common system calls in a commodity OS.
For example, \funcname{StreamRead} and \funcname{StreamWrite} can directly map to the POSIX functions \funcname{pread} and \funcname{pwrite}, which are available in most OSes including Linux, BSD, OS X, and Windows.
More than half of the functions in the host ABI can be counted toward this category.
The rest of the host abstractions are either specific to Linux
(e.g., TLS support),
or belong to the POSIX functions that are not shared with commodity OSes
(e.g., \funcname{mmap} on Windows).
The PAL emulates these host abstractions, using existing system interfaces available on the host OS, unless the software emulation is fundamentally impossible (e.g., restricted by the system interfaces), or too expensive (e.g., high overhead from copying data).





\subsection{Host-specific security isolation}
\label{sec:overview:host:security}


The security isolation of \graphene{} ensures that mutually distrusting applications cannot interfere with each other. The mechanism of isolation is comparable to running each applications in separate virtual machines.
To ensure isolation, each host must restrict access from the applications or the library OS, to any unauthorized host abstractions.
On most hosts, a reference monitor in the host kernel can enforce the access control on the host system interfaces, files, network addresses, and RPC streams.
The only exception is the Intel SGX platform; in SGX, not only applications distrust each other, an application also assume the host kernel to be untrustworthy.
In this case, an application running inside an enclave must enforce isolation internally using software techniques (e.g., encryption).


%\graphene{} reduces the attack surface exposed to applications
%by restricting access to the host kernel ABI 
%and prevents access to unauthorized system calls, files, byte streams,
%and network addresses with a \emph{reference monitor}.
%The host kernel ABI exported by the \pal{} heavily 
%limits the ability of a \graphene{} application to interact with the rest of the system;
%any external interactions are further mediated by a reference monitor.
%Unlike a typical Linux system, \graphene{} applications cannot interact with shared 
%system daemons or other shared system resources.
%As a result, \graphene{} enforces security isolation similar to running applications in separate VMs---even
%applications that span multiple processes.
\graphene{} contributes a multi-process security model 
based on the abstraction of a \emph{sandbox},
or a set of mutually trusting processes.
If a reference monitor exists, the reference monitor permits the processes within the same sandbox to communicate and exchange RPC messages, but disallows cross-sandbox communication.
The current work focuses on all-or-nothing security isolation, although we expect
this design could support
controlled communication among mutually distrusting \liboses{}
in future work.

The only host abstractions that are shared across processes and must be mediated by the host for isolation are files, network sockets, and RPC streams
--- all other allowed host ABI modify only local process state, such as VMAs and threads.
%Thus, the reference monitor need only mediate file access, socket and RPC stream creation.
%an unprivileged daemon
%as well as extensions to the App\-Armor LSM~\cite{apparmor},
%which checks file and socket policies in the kernel.
%, reducing context switching overhead
%and the risk of race conditions~\cite{garfinkel03traps}.
In order for the reference monitor to restrict file access, socket and RPC stream creation,
each application includes a {\em manifest file}~\cite{hunt07rethink},
which describes a {\tt chroot}-like, restricted view of the local 
file system (similar to Plan 9's unioned file system views~\cite{pike90plan9}),
%including read-only shared files,
as well as {\em iptables}-style~\cite{iptablesman} network firewall rules.
To facilitate sharing read-only libraries, a manifest may specify a file system view which combines several different sub-directories of the local file system, and can prevent writing to files or directories.


For example, the \graphene{} reference monitor on the Linux host is implemented using \syscall{ioctl} to a special device (\code{/dev/graphene})~\fixme{a prospective design}.
A process is restricted by the Linux BPF-style system call filter, or the SECCOMP filter~\cite{seccomp}, to use \syscall{open} to access any files, or to \syscall{connect} or \syscall{bind} to any sockets.
It must use the \graphene{} special device to open or create streams, so the file paths or network addresses can be checked against the sandbox rules. The kernel module as the driver of the \graphene{} special device can coexist with any Linux Security Module (LSM), such as AppArmor~\cite{apparmor} or SELinux~\cite{selinux}.


When a new process is launched by the host, it begins execution in a new sandbox.  
Child processes may either inherit their parent's sandbox, or can be started in a separate sandbox---specified by a flag to the host abstractions of process creation.
A parent may specify a subset of its own file system view 
when creating a child, but may not request access to new regions of the host file system. 
%The restrictive policy enforced on the child will be written in a new manifest file generated by the parent, and the policy will be checked by the reference monitor.
The child may also issue an {\tt ioctl} call to 
dynamically detach from the parent's sandbox. The reference monitor prevents byte stream creation across sandboxes.
%among picoprocesses
%that are not in the same sandbox.
%and restricts external connections to remote URIs according to firewall rules in the manifest.
When a process detaches from a sandbox, effectively splitting the sandbox, the host must closes all RPC streams that could bridge the two sandboxes.

\paragraph{Threat model.}
On a host with a reference monitor, the host OS and the reference monitor are both trusted, to mediate all system interfaces used to implement the host ABI. The host must check all access to any abstractions with effects outside of a process's internal state, such as an opened file, or a connected network socket.
Processes inside the same sandbox mutually trust each other. The adversary can run arbitrary code inside of one or more processes within one or more sandboxes.
The adversary can control all code in its processes, including the library OS and the host-specific PAL.
%{\tt libLinux} and the \pal{}. 
%We also assume a trusted reference monitor process running on the host kernel that 
%launches \graphene{} applications and mediates all system calls with external effects,\fixmedp{define precisely}

%\graphene{} ensures that %The key security property the \graphene{} design upholds is that 
%the adversary cannot interfere with any victim picoprocesses
%in a separate sandbox.  
%The \graphene{} sandbox design ensures strict isolation: 
%if the only shared kernel abstractions are byte streams and files, 
%and the reference monitor ensures
%there is no writable intersection between sandboxes,
%the adversary cannot interfere with any victim picoprocess.


%%% The only processes allowed to run as standard kernel processes (non-\graphene{}) 
%%% are the reference monitor and
%%% system administration utilities that need more kernel interfaces than the \pal{} ABI provides.
%%% Ensuring that a collaborating picoprocess correctly implements
%%% some function (such as receiving a signal),
%%% as well as preventing exploitation of vulnerabilities in picoprocesses
%%% are beyond the scope of this work.

%\graphene{} reduces the system attack surface of the host, but does not change the size of its
%trusted computing base; however, reducing the effective system call table
%size of a picoprocess does facilitate adoption of a smaller host kernel,
%which we leave for future work.

