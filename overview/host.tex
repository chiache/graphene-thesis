\section{The Host ABIs}
\label{sec:overview:host}

%\fixme{each sentense should be a paragraph; starting the 2nd sentence}
The \graphene{} host ABIs
describe the OS functions needed from a host,
to reuse an application and all its supporting libraries, including the \graphene{} library OS. 
For each host which requires the compatibility for unmodified Linux applications, one only has to implement the narrowed host ABIs,
instead of reimplementing the bloated, ``legacy'' system interfaces
needed by the applications.
The host ABIs decouple the OS development in the host and the implementation of compatibility for the existing Linux application.
What the host ABIs expose is a simplified OS as a consistent, host-independent,  extended machine,
on which another layer of virtualization (i.e., the library OS) can be built to reproduce the compatibility for Linux.

The definition of the host ABIs must be both
{\em simple} (i.e., minimizing the difficulty of porting per host)
and {\em sufficient} (i.e., containing all necessary host functions for implementing the Linux functionality in the library OS).
For the simplicity, \graphene{} reduces the host functions
to the bare minimum.
In the simplest host ABIs, none of the host functions shall be able to internally implement the behavior of another host function,
or the definition of the host ABIs is further reducible.
Moreover, the host ABIs contain the most common OS functions
offered on most of the potential hosts,
so the implementation of the host ABIs shall be as straightforward as redirecting to the closest host-specific system interfaces,
such as the Linux system calls or the Windows APIs.


For sufficiency, the host ABIs cover the typical categories of OS functions, such as process management,
memory management, and I/O management~\cite{dhamdhere2007os-textbook},
as demonstrated in Table~\ref{tab:overview:abi}.
The host ABI inherits the high-level definition of the host ABIs from a prior work called \drawbridge{}~\cite{porter11drawbridge},
which is used by a library OS to run a single-process Windows application
in a lightweight, guest environment.
%The definition of the \drawbridge{} host ABI is a hint, for creating a list of host abstractions necessary for the library OS, including streams, memory, threads, and processes. 
If the host ABIs are insufficient for implementing a certain legacy OS service in the library OS, one may extend the host ABIs with the missing functions.
The extension to the host ABIs must be disciplined, to keep the extension minimal, and to avoid adding redundant functions.


%A host ABI (application binary interface) has to define the convention of application binaries, including the binary format and the linking procedure, as well as a set of  system interfaces.
The host ABIs contain a minimal loader which recognizes a basic version of the ELF (Executable and Linkable Format), just enough to compose a binary of the library OS.
The very initial loading procedure as part of the host ABIs only loads a clean library OS instance.
%Each host of \graphene{} is supposed implement a minimal dynamic loader,
%which can load the \graphene{} library OS binary in ELF.
The library OS then completes the dynamic loading procedure,
by directly loading the Linux native dynamic loader (i.e., \code{ld.so}), and indirectly loading the rest of the application binaries.

%ill loads and links the rest of application binaries, just like the native Linux loader (i.e., \code{ld.so}).




\subsection{Host functions}
\label{sec:overview:host:palcalls}


\fixmedp{the beginning doesn't capture the whole paragraph.}
The host ABI shares several common abstractions with production OSes. The interfaces, as part of the host ABI, which access these host abstractions, are ultimately simplified to reduce the porting effort on each host.
Unlike the system interfaces in the OS, the host ABI does not prioritize backward compatibility. Therefore, the host ABI includes only the minimum interfaces that the library OS needs to interact with the host. The host ABI does not have to include any of  the legacy system interfaces from a production OS, let alone preserving different flavors of system interfaces for backward compatibility.




\fixmedp{give more of the background}
The host ABI is also complemented with several Linux-specific abstractions, such as exception handing and the control of segment registers (i.e., \code{FS}/\code{GS} registers).
The host ABI contains \palcalls{} host functions (Table~\ref{tab:overview:abi}), which can be directly called from the library OS. \graphene{} shows that the host ABI is sufficient to implementing a large portion of the Linux system calls.


\begin{table}[htp!]
\centering
\input{abi}
\caption{Overview of the \graphene{} host abstractions. The abstractions marked with the symbol $\dagger$ are introduced in \graphene{}. The rest abstractions are inherited and extended from \drawbridge{}.}
\label{tab:overview:abi}
\end{table}


The host ABI also implements two types of remote procedure call (RPC) primitives.
\funcname{StreamSendHandle} and \funcname{StreamRecvHandle}
allow delegation of an open stream handles to another process, through a connecting pipe. The feature is similar to sending file descriptors through UNIX sockets in Linux, and is used to share opened network sockets with the \syscall{fork}'ed processes.
Another RPC abstraction is a bulk IPC channel; a process can use \funcname{PhsyicalMemoryCommit} to commit a large chunk of memory to a bulk IPC channel, which \funcname{PhsyicalMemoryMap} can map into another process, as copy-on-write. The library OS uses bulk IPC as an optimization to \syscall{fork}.


To simplify isolation, the functions to access each host abstraction must appear \fixmedp{clarify `stateless'} stateless to the host, except for the handles to identify the resources. Each call to the host functions is independent. The arguments given for each call must be always be absolute values, instead of relative values.
For example, the offset given to \funcname{StreamMap}, \funcname{StreamRead}, and \funcname{StreamWrite} (if the opened handle is a file) are offsets from the beginning of the file, and thus are irrelevant to how many bytes that are previously written or read.
When enforcing isolation rules, the host OS can check the arguments of each calls to the host functions, independently and atomically.

\subsection{Porting to different hosts}
\label{sec:overview:host:porting}


The compatibility of \graphene{} relies on each host to implement the host ABI.
The host ABI is defined for the simplicity of porting.
First of all, the number of abstractions included in the host ABI
is objectively smaller than the number of system interfaces in a production OS (e.g., system calls in Linux). 
The simplicity of porting the host ABI is experimented by the development of
several ``classic'' ports, including the ports to Windows, Linux, OS X,
\fixme{the last two are prospective}
the L4 microkernel, and Barrelfish.
For each port, the amount of code written for implementing the host ABI is at the order of magnitude of thousands of lines of code, which is much more manageable than implementing a flat translation layer for system interfaces.


For each port of the host ABI, the OS developers implement a thin translation layer,
or platform translation layer (PAL). The PAL must translate the host abstractions, to the system interface native to the target host. 
The PAL must also be a dynamic loader, which implements the minimal loading feature included in the host ABI.
For a host OS that does not support ELF binaries, the PAL must follow the binary format which the host OS accepts, such as the Portable Executable (PE) format on Windows.
The PAL is the only layer in the user space which cannot be reused
across different hosts. Besides the PAL, all of the other binaries in the user space are fully reusable, including the library OS, the supporting libraries, and the application executable.



The host abstractions map to several system interfaces in production OSes.
For example, \funcname{StreamRead} and \funcname{StreamWrite} can directly map to the POSIX functions \funcname{pread} and \funcname{pwrite}, which are available in most OSes including Linux, BSD, OS X, and Windows.
More than half of the functions in the host ABI can be counted toward this category.
The rest of the host abstractions are either specific to Linux
(e.g., TLS support),
or belong to the POSIX functions that are not shared by all production OSes
(e.g., \funcname{mmap} on Windows).
The PAL emulates these host abstractions, using existing system interfaces available on the host OS, unless the software emulation is fundamentally impossible (e.g., restricted by the system interfaces), or too expensive (e.g., high overhead from copying data).





\subsection{Security isolation}
\label{sec:overview:host:security}


The security isolation of \graphene{} ensures that mutually distrusting applications cannot interfere with each other. The mechanism of isolation is comparable to running each applications in separate virtual machines.
To ensure isolation, each host must restrict access from the applications or the library OS, to any unauthorized host abstractions.
On most hosts, a reference monitor in the host kernel can enforce the access control on the host system interfaces, files, network addresses, and RPC streams.
The only exception is the Intel SGX platform; in SGX, not only applications distrust each other, an application also assume the host kernel to be untrustworthy.
In this case, an application running inside an enclave must enforce isolation internally using software techniques (e.g., encryption).


%\graphene{} reduces the attack surface exposed to applications
%by restricting access to the host kernel ABI 
%and prevents access to unauthorized system calls, files, byte streams,
%and network addresses with a \emph{reference monitor}.
%The host kernel ABI exported by the \pal{} heavily 
%limits the ability of a \graphene{} application to interact with the rest of the system;
%any external interactions are further mediated by a reference monitor.
%Unlike a typical Linux system, \graphene{} applications cannot interact with shared 
%system daemons or other shared system resources.
%As a result, \graphene{} enforces security isolation similar to running applications in separate VMs---even
%applications that span multiple processes.
\graphene{} contributes a multi-process security model 
based on the abstraction of a \emph{sandbox},
or a set of mutually trusting processes.
If a reference monitor exists, the reference monitor permits the processes within the same sandbox to communicate and exchange RPC messages, but disallows cross-sandbox communication.
The current work focuses on all-or-nothing security isolation, although we expect
this design could support
controlled communication among mutually distrusting \liboses{}
in future work.

The only host abstractions that are shared across processes and must be mediated by the host for isolation are files, network sockets, and RPC streams
--- all other allowed host ABI modify only local process state, such as VMAs and threads.
%Thus, the reference monitor need only mediate file access, socket and RPC stream creation.
%an unprivileged daemon
%as well as extensions to the App\-Armor LSM~\cite{apparmor},
%which checks file and socket policies in the kernel.
%, reducing context switching overhead
%and the risk of race conditions~\cite{garfinkel03traps}.
In order for the reference monitor to restrict file access, socket and RPC stream creation,
each application includes a \emph{manifest file}~\cite{hunt07rethink},
which describes a {\tt chroot}-like, restricted view of the local 
file system (similar to Plan 9's unioned file system views~\cite{pike90plan9}),
%including read-only shared files,
as well as \emph{iptables}-style~\cite{iptablesman} network firewall rules.
To facilitate sharing read-only libraries, a manifest may specify a file system view which combines several different sub-directories of the local file system, and can prevent writing to files or directories.


For example, the \graphene{} reference monitor on the Linux host is implemented using \syscall{ioctl} to a special device \fixme{a prospective design}\code{/dev/graphene}.
A process is restricted by the Linux SECCOMP filter~\cite{seccomp}, to use any \syscall{open}, or \syscall{connect} and \syscall{bind} to sockets.
It must use the \graphene{} special device to open or create streams, so the file paths or network addresses can be checked against the sandbox rules. The kernel module as the driver of the \graphene{} special device can coexist with any Linux Security Module (LSM), such as \emph{AppArmor} or \emph{SELinux}.


When a new process is launched by the host, it begins execution in a new sandbox.  
Child processes may either inherit their parent's sandbox, or can be started in a separate sandbox---specified by a flag to the host abstractions of process creation.
A parent may specify a subset of its own file system view 
when creating a child, but may not request access to new regions of the host file system. 
%The restrictive policy enforced on the child will be written in a new manifest file generated by the parent, and the policy will be checked by the reference monitor.
The child may also issue an {\tt ioctl} call to 
dynamically detach from the parent's sandbox. The reference monitor prevents byte stream creation across sandboxes.
%among picoprocesses
%that are not in the same sandbox.
%and restricts external connections to remote URIs according to firewall rules in the manifest.
When a process detaches from a sandbox, effectively splitting the sandbox, the host must closes all RPC streams that could bridge the two sandboxes.

\paragraph{Threat model.}
On a host with a reference monitor, the host OS and the reference monitor are both trusted, to mediate all system interfaces used to implement the host ABI. The host must check all access to any abstractions with effects outside of a process's internal state, such as an opened file, or a connected network socket.
Processes inside the same sandbox mutually trust each other. The adversary can run arbitrary code inside of one or more processes within one or more sandboxes.
The adversary can control all code in its processes, including the library OS and the host-specific PAL.
%{\tt libLinux} and the \pal{}. 
%We also assume a trusted reference monitor process running on the host kernel that 
%launches \graphene{} applications and mediates all system calls with external effects,\fixmedp{define precisely}

%\graphene{} ensures that %The key security property the \graphene{} design upholds is that 
%the adversary cannot interfere with any victim picoprocesses
%in a separate sandbox.  
%The \graphene{} sandbox design ensures strict isolation: 
%if the only shared kernel abstractions are byte streams and files, 
%and the reference monitor ensures
%there is no writable intersection between sandboxes,
%the adversary cannot interfere with any victim picoprocess.


%%% The only processes allowed to run as standard kernel processes (non-\graphene{}) 
%%% are the reference monitor and
%%% system administration utilities that need more kernel interfaces than the \pal{} ABI provides.
%%% Ensuring that a collaborating picoprocess correctly implements
%%% some function (such as receiving a signal),
%%% as well as preventing exploitation of vulnerabilities in picoprocesses
%%% are beyond the scope of this work.

%\graphene{} reduces the system attack surface of the host, but does not change the size of its
%trusted computing base; however, reducing the effective system call table
%size of a picoprocess does facilitate adoption of a smaller host kernel,
%which we leave for future work.

