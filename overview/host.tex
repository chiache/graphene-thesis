\section{The Host ABI}
\label{sec:overview:host}

\issuedone{1.1.b}{describe the host ABI specification}
\graphene{} facilitates compatibility
by partitioning an OS
at a narrowed interface that contains
OS abstractions
that are essential to application execution.
%and minimal specifications for the host OSes and hardware.
%The host ABI is a new boundary between OSes (or hypervisors) and applications.
The host ABI separates the low-level, hardware management features, from the idiosyncrasy of system interface. 
\graphene{} moves the upper layer of OS components,
including the system calls and namespaces, into an library OS,
leaving the host ABI 
as a narrowed interface to the host OSes and hardware.
%The host ABI intends to minimize the development effort on each host OS or hardware
%to mitigate the interface distinctions,
%to simply porting the OS abstractions defined in the host ABI.






 
%The host ABI defines the interaction between the library OS and a specific host.
%The \graphene{} library OS can be deployed on any ``host'' where the host ABI has been ported.
We define a {\bf host} as an OS or a hypervisor
which run an application or a VM
on a physical machine.
For example, a commodity OS, such as Linux, BSD, or Windows, can be a host to the library OS,
with portability on different hardware.
An innovative hardware abstraction like SGX (software guard extensions)
imposes unique assumptions and restrictions
on a commodity OS,
%creates a special host on top of Linux or Windows,
%with unique interfaces and specifications regarding the host OSes.
and thus creates a special host above the OS.

%If an OS has mutated or tweaked the interface for a hardware platform,
%such as an SGX enclave 
%running on an untrusted Linux kernel,
%the combination of the OS (Linux) and the hardware platform (SGX) is considered a specialized host.
%Especially, the SGX port of the host ABI faces several unique challenges,
%which will be discussed in Chapter~\ref{chap:sgx}.


\begin{comment}
%\fixme{each sentense should be a paragraph; starting the 2nd sentence}
\fixmedp{start with a strong opening stating the rationale}
The host ABI of \graphene{}
define functions needed from a host, in order to implement the library OS for reusing applications.
%to reuse an application and all its supporting libraries, including the \graphene{} library OS.
Each host of \graphene{} contains an OS and a hardware platform, either of which causes compatibility issues for running unmodified applications.
OS developers can port the library OS to a new host,
by simply reimplementing the narrowed host ABIs using abstractions available on the host.
%a new host platform.
%For each host which requires the compatibility for unmodified Linux applications, one only has to implement the narrowed host ABIs,
%instead of reimplementing the bloated, ``legacy'' system interfaces
%needed by the applications.
By implementing the host ABI, OS developers skip the painful process of rebuilding the whole system interfaces of a commercial OS such as Linux.
The host ABIs strictly decouples the porting effort on the hosts from the compatibility feature for applications.
%The host ABIs decouple the OS development in the host and the implementation of compatibility for the existing Linux application.
What the host ABI exposes is a simplified extended machine,
similar to a para-virtualization interface, capable of running the library OS as a lightweight virtual machine. % with compatibility against Linux applications.
%on which another layer of virtualization (i.e., the library OS) can be built to reproduce the compatibility for Linux.
\end{comment}


\begin{comment}
Two design principles drive the definition of the host ABIs:
{\em simplicity} (i.e., easy to port on any hosts)
and {\em sufficiency} (i.e., containing enough OS functions for implementing a library OS).
The process of deciding the host ABIs is comparable to
finding a ``pinch point'' within a OS implementation,
which can conveniently mediate a significant portion of OS execution paths for managing hardware abstractions.
%The two principles drive the development of the host ABIs,
%The whole development of the \graphene{} library
%must be disciplined
%on extending the host ABIs only when it is strongly required.
%of restraining extensions to the host ABIs unless absolutely necessary.
The two principles
determine the soundness of the \graphene{} approach to improving compatibility
for any hosts.
\end{comment}


%The host ABI is defined with partitioning in mind.
\Thehostabi{} 
determines a boundary which partitions several upper-level OS components, %, such as system calls and namespaces,
into a library OS,
%, as a dynamically-linked library which can be deployed
%to various hosts.
%The rationale behind the partitioning is based on the fact that not every OS component is equally important to compatibility, for applications which need to be ported across hosts.
%When an OS is extended for a new hardware,
%these OS components usually remain unchanged, or are predominantly reused.
%Partitioning
%into a library OS further guards these 
in order to isolate the host idiosyncrasy. % on specific hardware. %any potential changes for adopting new hardware.
%Similar isolation
%exists in traditional OSes, but without partitioning:
The strategy
is also used in OSes:
An example is the Linux virtual file system (VFS), an internal interface
which encapsulates operations of file system drivers.
%On the other hand,
%drivers (e.g., drivers for file systems, block devices, or network cards)
%and architecture-specific instructions
%stay encapsulated in the host OS.
%in the Linux kernels are usually encapsulated under a virtualized, in-kernel interface (e.g., the Linux virtual file system),
%to simplify the development of the rest of the kernel.
Similar to VFS,
the host ABI is intended
to be a more ubiquitous interface,
which encapsulates
any host-specific behavior and semantic
inside the host OS.
%for encapsulating both OS and hardware idiosyncrasy on a wide range on hosts.
%declares a ubiquitous system interface, to encapsulate both OS and hardware abstractions
%for the library OS.




\Thehostabi{}  shares several characteristics of a virtual hardware interface for running a VM.
A hypervisor usually export a generic, but backward-compatible
virtual hardware interface,
%a set of generic, virtual hardware,
%which the VM can control with the same drivers.
to port an unmodified OS into a VM.
%by exporting interfaces close to commodity hardware.
%To avoid additional porting effort, the virtual hardware are close to the typical commodity hardware.
For example, a virtual ethernet card in VMware workstation or QEMU
emualates an Intel E1000 device.
%The host ABI does not mimic a commodity hardware, but is meant to be translatable from a common host system interface. 
%As a result, the host ABI contains the
%typical OS features and interfaces, similar to the API of early UNIX systems.
However, unlike a virtual hardware interface, the host ABI does not reuse a whole, unmodified OS.
Instead, \thehostabi{} expects the \libos{}
to be rewritten and
customized for \thehostabi{},
similar to a 
para-virtualizated VM.
%Compared to an actual para-virtualized VM,
Moreover, \graphene{} deduplicates OS components,
such as scheduler, page fault handler, file system, and network stack,
between the host and the \libos{}.
%Another difference is that the host ABI is called by normal function calls, whereas para-virtualization relies on hypercalls.
Overall, we can put a \libos{} and a VM on a spectrum:
while a VM tries to reuse most of an OS and runs on a virtual hardware interface,
a \libos{}
partitions an OS
at a narrowed interface.




\paragraph{Simplicity of the host ABI.}
To reduce the burden of OS developers, the host ABI is designed to simple to port on a new host.
The amount of porting effort is subjective to OS developers,
but can be reduced with two strategies:
the first is to narrow the size of the host ABI;
Although narrowness does not indicate simplicity, removing redundant OS functions or corner cases
makes porting easier.
%The development of \graphene{} disciplinarily avoiding adding any functions to the host ABI,
%unless the library OS cannot internally implement an OS feature.
The second strategy is to include functions which can be directly mapped to OS functions exported by the host.
%the likelihood of finding similar features on the host, to be translated to functions in the host ABI.
An observation of OS development is that
%similarity of system interfaces is common among most OSes.
similar OS functions tend to exist in different OSes.
%, to reduce the learning curve for programming applications.
We can find system call lookalikes in many OSes: for example, \syscall{read} in Linux, BSD, and POSIX
looks similar to \syscall{ReadFile} in Windows, except the data types.
%The definition of the host ABI
%is based on observations of the system interfaces in some of the important hosts,
%including Linux system calls and Windows API.
%exported by the targeted hosts,
%and defines the functions in the host ABI, to be easily translated to the native system interfaces.
%The host ABI is essentially a subset of the common features from every potential hosts.
%We expect %the host ABI defined with simplicity in mind
%to be straightforward to port on most hosts,
Most functions in the host ABI can be easily translated to host system interfaces
in various styles.

%For example, the host ABI defines \syscall{StreamRead} and \syscall{StreamWrite} for accessing I/O streams, similar to .
%xcept some nuanced details like order of parameters.


% by including OS functions , such as \syscall{FileRead} and \syscall{FileWrite}, similar to the Linux system calls, \syscall{pread} and \syscall{pwrite}.




\begin{comment}
The simplicity of the host ABIs requires retaining a minimalist design of host functions. %, based on typical OS services for managing hardware.
%\graphene{} reduces the host functions
%to the bare minimum.
The host ABIs should only contain operations that
are absolutely necessary for requesting external hardware abstractions.
%A way to simplify the host ABIs is to move host functions into the library OS
%and to replace them with wrappers consisting of other host functions.
Any functions that can be partially or wholly implemented inside the library OS
should be further simplified, or even removed from the host ABIs.
%---in other words, whether the host ABIs can be further reduced.
Moreover, the host ABIs have to be simple enough to implement on
most hosts;
%In the simplest host ABIs, none of the host functions shall be able to internally implement the behavior of another host function,
%or the definition of the host ABIs is further reducible.
that is, the host ABIs should contain only OS functions that are commonly offered on
most hosts.
The host ABIs are close to simplified UNIX interfaces,
such as reading or writing a file or an I/O device as a byte stream,
or creating a virtual memory mapping.
%the most common OS functions
%offered on most of the potential hosts,
For most hosts,
implementing the host ABI should be as straightforward as redirecting the functions to the closest host system calls.
%such as the Linux system calls or the Windows APIs.
For example, the functionality of \syscall{StreamRead} and \syscall{StreamWrite} in the host ABIs can loosely match with
\syscall{read} and \syscall{write} in Linux,
or \syscall{ReadFile} and \syscall{WriteFile} in Windows.
%This thesis also evaluates the simplicity of the host ABIs by counting the lines of code used to implement the host ABIs on each host platforms.
Since most OSes have inherited a similar design from UNIX,
it is fair to assume finding
comparable OS functions %host platforms
to the host ABI would be reasonably easy.
%fair to assume that the host ABIs 
\end{comment}



\paragraph{Sufficiency of the host ABI.}
The host ABI is responsible for exporting sufficient functionality to the library OS,
for requesting hardware or OS abstractions which cannot be easily virtualized in user space.
For sufficiency, the host ABI
%are demonstrated by the fact that
%the exported host functions 
covers a set of typical OS functions.
%and a full-function library OS is implemented on top of them.
The typical OS functions in most OSes
%can be categorized into five types:
includes
process creation, memory management, I/O (typically, files and network connection), security and protection~\cite{dhamdhere2007os-textbook}.
%Besides security and protection,
%the definition of the host ABI is closely related with hardware management,
%and offers the most basic abstractions for each category of OS functions.
%managing specific types of hardware,
%and each contain a few basic abstractions
%which can be expanded into other system interfaces.
%For example, the basic OS functions for memory management include
%allocating (\syscall{VirtMemAlloc}),
%protecting (\syscall{VirtMemProt}),
%and deallocating (\syscall{VirtMemFree}) memory regions. % at certain granularity
%(usually in pages).
%These basic functions can be used to implement other forms of memory allocation,
%such as growing heaps with \syscall{brk}
%or allocating thread-private stacks.
%The definition of the \drawbridge{} host ABI is a hint, for creating a list of host abstractions necessary for the library OS, including streams, memory, threads, and processes. 
%If the host ABIs are insufficient for implementing certain system interfaces, one may extend the host ABIs with the missing functions,
%with the discipline to retain the simplicity of the host ABIs.
%The extension to the host ABIs must be d, to keep the extension minimal, and to avoid adding redundant functions.
%The implementation of the \graphene{} library OS demonstrates that
%the host ABI is sufficient for implementing significant portion of Linux system calls.
Linux defines multiple system calls with similar purposes.
For example, both \syscall{mmap} and \syscall{brk} can allocate memory in a process:
\syscall{mmap} allocates memory regions at page granularity, whereas \syscall{brk} grows a single, continuous heap space.
\graphene{} shows
that a basic OS function is sufficient to implement all the idiosyncratic variants in the Linux system interfaces. Both \syscall{mmap} and \syscall{brk} can be implemented using \syscall{VirtMemAlloc} in the host ABI, with bookkeeping of allocated memory regions in the library OS.


The definition of the host ABI in \graphene{} is based on a prior work ca
\drawbridge{}~\cite{porter11drawbridge}.
\drawbridge{} is a library OS for running single-process Windows applications
in a lightweight, guest environment.
\drawbridge{} 
defines a host ABI, including 36 functions, to develop its library OS.
%demonstrates that its host ABI is sufficient
%for running a library OS in which 99.7\% of code comes from the Windows 7 source.
%The host ABIs of \drawbridge{} are later extended
%for running a Linux-based library OS called Bascule~\cite{baumann13bascule}.
The \drawbridge{} host ABI
is ported to multiple hosts, including Windows, Linux, Barrelfish, and Intel SGX~\cite{porter11drawbridge,baumann14haven,mssql-on-linux,baumann13bascule},
and is capable of running a library OS for single-process, Linux applications, with a few host ABI changes~\cite{baumann13bascule}.
%ill loads and links the rest of application binaries, just like the native Linux loader (i.e., \code{ld.so}).
%\graphene{} takes the high-level definitions of the \drawbridge{} and Bascule host ABIs, and customizes for general-purpose Linux applications and a wider range of hosts. 
Although running Windows and Linux applications introduces
a different set of challenges,
the nature of the Linux and Windows APIs is actually quite similar, with some exceptions.
During the development of \graphene{}, we found a few occasions in which we have to extend the host ABI to deal with Linux-specific challenges. The Linux-specific extensions will be further discussed in Section~\ref{sec:overview:host:functions} and Chapter~\ref{chap:abi}.


\paragraph{Checkpointing and migration.}
The \graphene{} library OS shares several features of VMs, including the convenience of checkpointing a running application and migrating to other hosts.
The migration feature is also the key to implementing copy-on-write forking for applications,
on a host which disallows memory sharing (e.g., SGX).
For a VM, checkpointing and migration is based on using the virtual hardware interface as a clean boundary for snapshotting the application and OS state.
The host ABI in \graphene{} shares the same quality with the virtual hardware interface,
as being as {\em stateless} as possible.
The statelessness of the host ABI guarantees any states in the hosts are temporary to the applications and the library OS, and can be reproduced without any snapshotting in the hosts.





\subsection{\hostapis{}}
\label{sec:overview:host:abi}


%\fixmedp{the beginning doesn't capture the whole paragraph.}
%The host ABI shares several common abstractions with production OSes.
%The functions in the host ABI
%define the basic features needed from the hosts, to run the library OS.
%The definition of the host functions
%should be unsurprising to average OS developers,
%making the implementation on a new host to be fairly straightforward.
%The host ABI reflects the common functionality of most OSes, including Linux and Windows.
%Although the same OS abstractions may be defined
%as different idiosyncratic system interfaces on each host OSes,
%\graphene{} takes into consideration of porting the host functions to either OSes, in the most effortless way possible.





%fixmedp{give more of the background}
Table~\ref{tab:overview:abi} lists \palcallnum{} \hostapis{} defined in the host ABI of \graphene{}.
%Among these \hostapis{}, 
27 are inherited from the \drawbridge{} host ABI,
including functions to managing I/O (e.g., \palcall{StreamOpen}), memory allocation (e.g., \palcall{VirtMemAlloc}), scheduling (e.g., \palcall{ThreadCreate}), and several miscellaneous functions (e.g., \palcall{SystemTimeQuery}).
%Most of the host functions only affect the OS or hardware states
%related to the process itself.
%For example, \syscall{VirtMemAlloc} can only allocate memory in the calling process,
%and cannot affect other processes running in parallel.
%Only I/O streaming functions export states to the host OS, and share states with other processes or library OSes.
Only 8 functions are added by \graphene{}, in order to implement Linux-specific features.
For example, unlike Windows or OSX, Linux generally
%The host ABI is also complemented with several Linux-specific abstractions, such as
delivers hardware exceptions to a process as signals .
Linux also requires 
the x86-specific segment registers (i.e., FS/GS registers)
to determine the location of thread-local storage (TLS), which can be hard-coded in application binaries by a compilation mode of GCC.
However, in Windows or OSX, the x86-specific segment registers are mostly ignored, and even frequently reset to avoid being manipulated by attackers.
%The host ABI contains host functions (), which can be directly called from the library OS. \graphene{} shows that the host ABI is sufficient to implementing a large portion of the Linux system calls.
%These functions are not defined in \drawbridge{}, the Windows-based library OS,
%because these abstractions do not exist in Windows.
%The \drawbridge{} host ABI does not contain exception delivery because the feature is
%not commonly used in Windows applications.
%Moreover, the x86 segment registers cannot be modified in Windows
%because the OS assigns fixed values to these registers
%for the whole execution.
%Although \drawbridge{} excludes these abstractions, Bascule extends the host ABI to include similar functions,
%demonstrating that the extension is indeed necessary.




\begin{table}[htp!]
\centering
\input{abi-table}
\caption{An overview of the host ABI of \graphene{}. The ones marked with the symbol $\dagger$ are introduced in the initial publication of \graphene{}~\cite{tsai14graphene} or later extended for this thesis. The rest are inherited from \drawbridge{}~\cite{porter11drawbridge}.}
\label{tab:overview:abi}
\end{table}

%The interfaces, as part of the host ABI, which access these host abstractions, are ultimately simplified to reduce the porting effort on each host.
%Unlike the system interfaces in the OS, the host ABI does not prioritize backward compatibility. Therefore, the host ABI includes only the minimum interfaces that the library OS needs to interact with the host. The host ABI does not have to include any of  the legacy system interfaces from a production OS, let alone preserving different flavors of system interfaces for backward compatibility.



The host ABI also include 5 functions for 
remote procedure call (RPC),
in order to implement Linux multi-process abstractions.
The rationale of the multi-process support in \graphene{} is to reduce the complexity of inter-process communication in the host.
A host to \graphene{} needs not to understand all the Linux-specific multi-process behaviors,
but only sees a pipe-like, RPC stream for message passing between processes.
To ensure performance to be acceptable,
%RPC is critical for implementing the coordination of OS states
%across library OS instances.
%The basic form of RPC in \graphene{} is a pipe-like RPC byte stream, which a library OS can simply use to send messages.
%It is a common design choice
%to implement inter-process coordination through message-passing
%instead of shared memory, especially for hardware platforms that do not guarantee memory coherence~\cite{baumann09barrelfish}.
%A problem to the message-passing approach is the significant overheads
%on frequently exchanging distributed OS states.
\graphene{} defines an optional, bulk IPC feature
in the host ABI
as optional host functions,
to send large chunks of memory across processes.
The bulk IPC feature works similarly as sending the memory through RPC streams,
but is much faster because it avoids copying the memory in the host kernels.


%for host platforms that urgently require lowering the RPC overheads.
%Another extension is for
%%\funcname{StreamSendHandle} and \funcname{StreamRecvHandle}
%delegating opened stream handles to another process, through a connecting pipe.
%The feature is similar to sending file descriptors
%through UNIX sockets in Linux, and is used to share opened network sockets with the \syscall{fork}'ed processes.
%%Another RPC abstraction is a bulk IPC channel; a process can use \funcname{PhsyicalMemoryCommit} to commit a large chunk of memory to a bulk IPC channel, which \funcname{PhsyicalMemoryMap} can map into another process, as copy-on-write. The library OS uses bulk IPC as an optimization to \syscall{fork}.
%Despite that either of the RPC primitives
%is not necessary easy to implement on every hosts, the inclusion of these host functions is completely optional, and the library OS can always fall back to the message-passing approach.



%All the host functions are designed to appear as ``stateless''
%as possible to the library OS.
%Being stateless to the library OS means that
%a host function does not preserve any permanent state of certain host abstraction.
%A stateless function can recover
%from disconnection of the library OS, and be reconnected at any timing.
%The host functions can maintain temporary bookkeeping for the convenience of porting,
%but should not assume the bookkeeping states to be permanent.
%The principle of defining all the host functions to be stateless
%is primarily for two purposes:
%{\em migration} and {\em security isolation}.
%For migration, the fact that the library OS can disconnect freely from the host functions simplifies the implementation of the migration feature.
%Migration is also an important foundation to implementing \syscall{fork}, because the cloned process need to receive a snapshot of the parent process.
%For security isolation, 
%a stateless host function is easier to check,
%because the security monitor only has to verify each instance of host function calls,
%instead of tracing multiple host functions over a longer period of time.

%the functions to access each host abstraction must appear \fixmedp{clarify `stateless'} stateless to the host, except for the handles to identify the resources. Each call to the host functions is independent. The arguments given for each call must be always be absolute values, instead of relative values.
%For example, the offset given to \funcname{StreamMap}, \funcname{StreamRead}, and \funcname{StreamWrite} (if the opened handle is a file) are offsets from the beginning of the file, and thus are irrelevant to how many bytes that are previously written or read.
%When enforcing isolation rules, the host OS can check the arguments of each calls to the host functions, independently and atomically.


%A host ABI (application binary interface) has to define the convention of application binaries, including the binary format and the linking procedure, as well as a set of  system interfaces.
%The host ABIs contain a minimal loader which recognizes a basic version of the ELF (Executable and Linkable Format), just enough to compose a binary of the library OS.
%The very initial loading procedure as part of the host ABIs only loads a clean library OS instance.
%Each host of \graphene{} is supposed implement a minimal dynamic loader,
%which can load the \graphene{} library OS binary in ELF.
%The library OS then completes the dynamic loading procedure,
%by directly loading the Linux native dynamic loader (i.e., \code{ld.so}), and indirectly loading the rest of the application binaries.



\subsection{PAL (platform adaption layer)}
\label{sec:overview:host:pal}


\graphene{} relies on each host to implement the host ABI, using the native system interfaces on the host.
For each host, a platform translation layer (PAL)
is loaded below the library OS, to translate each functions in the host ABI to native system interfaces.
The development of a PAL is a effort paid per host, whereas the library OS is reusable on every hosts. %The simplicity of the host ABI can be also estimated by the effort of implementing a PAL for each host.
Based on the simplicity of the host ABI, the PAL development is supposed to be straightforward and easy for average developers, except corner cases on a few eccentric hosts, such as SGX.




%The host ABI is defined for the simplicity of porting, as well as the sufficiency for implementing a library OS compatible to Linux.
%First of all, the number of host functions included in the host ABI
%is much smaller than the number of system calls in a commodity OS such as Linux. 
\graphene{} is experimented with
several ``classic'' hosts, including Windows, Linux, OSX, FreeBSD, and Linux with SGX.
For most of these hosts,
implementing the host ABI is straightforward,
%Most of the host ABI is straightforward to port
%on these hosts, 
because most OSes have exported a version of the POSIX API, or similar API.
Few exceptions where the porting has been challenging
are mostly caused by usual assumptions made in the host OSes.
For example, the Windows API disallows directly resizing or protecting part of a memory region, which is essential to implementing the \syscall{munmap} and \syscall{mprotect} system calls.
A workaround for porting the host ABI to Windows is to change the memory region
at the physical page level,
but requires running the PAL in administer permission.

%In our experience, the development of a PAL is around ten thousand lines of code.

%For each port, the amount of code written for implementing the host ABI is at the order of magnitude of thousands of lines of code, which is much more manageable than implementing a flat translation layer for system interfaces.


Based on the experience in \graphene{},
even a host ABI specialized for simplicity cannot guarantee to be portable on every hosts.
It is possible that a host simply lacks the typical functionality
provided in other OSes.
As a principle, \graphene{} does not require each host to implement the whole host ABI,
but designs the library OS to flexibly switch emulation strategies
when a function is unavailable.
For example, when the bulk IPC feature is not available on the host,
the library OS can always switch back to the RPC-based IPC, with performance penalty.
In the worst case, if there is no emulation strategies
to compensate for the missing of a function,
at least users can predict whether an application will be affected and thus cannot run on certain hosts.



%For a host OS that does not support ELF binaries, the PAL must follow the binary format which the host OS accepts, such as the Portable Executable (PE) format on Windows.
%The PAL is the only layer in the user space which cannot be reused
%across different hosts. Besides the PAL, all of the other binaries in the user space are fully reusable, including the library OS, the supporting libraries, and the application executable.



%The host abstractions map to several common system calls in a commodity OS.
%For example, \funcname{StreamRead} and \funcname{StreamWrite} can directly map to the POSIX functions \funcname{pread} and \funcname{pwrite}, which are available in most OSes including Linux, BSD, OS X, and Windows.
%More than half of the functions in the host ABI can be counted toward this category.
%The rest of the host abstractions are either specific to Linux
%(e.g., TLS support),
%or belong to the POSIX functions that are not shared with commodity OSes
%(e.g., \funcname{mmap} on Windows).
%The PAL emulates these host abstractions, using existing system interfaces available on the host OS, unless the software emulation is fundamentally impossible (e.g., restricted by the system interfaces), or too expensive (e.g., high overhead from copying data).





\subsection{Security isolation}
\label{sec:overview:host:security}


To target multi-tenant environments, such as cloud,
\graphene{} has to ensure at least complete security isolation between mutually-untrusted applications running on the same host.
The security isolation of \graphene{} is comparable to running each application
in a VM, featuring a fully-isolated guest OS.
Similar to the virtual hardware interface isolating the VMs,
the host ABI also enforces security isolation between library OS instances,
according to the trust model of the applications.



\graphene{} delegates the enforcement of security isolation to the hosts.
The library OS and the application are mutually-trusted, as long as they are loaded in the same process.
The host ABI decouples the implementation of OS functionality
from the enforcement of security isolation.
%To ensure isolation, each host must restrict access from the applications or the library OS, to any unauthorized host abstractions.
On each host, a reference monitor will enforce security isolation policies assigned to the application, to control the access to the hardware abstractions managed by the host ABI, including files, network sockets, and RPC streams.
The hosts need not to be aware of the system interfaces and coordination of the OS states
inside of the library OS.
The security isolation in the hosts
is much more straightforward, simply based on monitoring the references
to the host abstractions.





%\graphene{} reduces the attack surface exposed to applications
%by restricting access to the host kernel ABI 
%and prevents access to unauthorized system calls, files, byte streams,
%and network addresses with a \emph{reference monitor}.
%The host kernel ABI exported by the \pal{} heavily 
%limits the ability of a \graphene{} application to interact with the rest of the system;
%any external interactions are further mediated by a reference monitor.
%Unlike a typical Linux system, \graphene{} applications cannot interact with shared 
%system daemons or other shared system resources.
%As a result, \graphene{} enforces security isolation similar to running applications in separate VMs---even
%applications that span multiple processes.



A host of \graphene{} will isolate applications in a {\em sandbox}, a container including one or multiple mutually trusting processes.
For a multi-process application, \graphene{} creates multiple library OS instances,
which will coordinate to construct a unified OS view.
As the library OS instances can coordinate shared OS states using simple RPC streams,
it is easy for the hosts to enforce security isolation.
The reference monitor simply has to block any RPC streams crossing the sandbox boundary,
to prevent applications in different sandboxes from interfering each other through manipulating IPC.
%\graphene{} contributes a multi-process security model 
%based on the abstraction of a \emph{sandbox},
%or a set of mutually trusting processes.
%If a reference monitor exists, the reference monitor permits the processes within the same sandbox to communicate and exchange RPC messages, but disallows cross-sandbox communication.
The current design focuses on security isolation in an all-or-nothing fashion, although we do expect to extend the design for more sophisticated policies
in the future.

\begin{comment}
The only host abstractions that are shared across processes and must be mediated by the host for isolation are files, network sockets, and RPC streams
--- all other allowed host ABI modify only local process state, such as VMAs and threads.
%Thus, the reference monitor need only mediate file access, socket and RPC stream creation.
%an unprivileged daemon
%as well as extensions to the App\-Armor LSM~\cite{apparmor},
%which checks file and socket policies in the kernel.
%, reducing context switching overhead
%and the risk of race conditions~\cite{garfinkel03traps}.
In order for the reference monitor to restrict file access, socket and RPC stream creation,
each application includes a {\em manifest file}~\cite{hunt07rethink},
which describes a {\tt chroot}-like, restricted view of the local 
file system (similar to Plan 9's unioned file system views~\cite{pike90plan9}),
%including read-only shared files,
as well as {\em iptables}-style~\cite{iptablesman} network firewall rules.
To facilitate sharing read-only libraries, a manifest may specify a file system view which combines several different sub-directories of the local file system, and can prevent writing to files or directories.


For example, the \graphene{} reference monitor on the Linux host is implemented using \syscall{ioctl} to a special device (\code{/dev/graphene})~\fixme{a prospective design}.
A process is restricted by the Linux BPF-style system call filter, or the SECCOMP filter~\cite{seccomp}, to use \syscall{open} to access any files, or to \syscall{connect} or \syscall{bind} to any sockets.
It must use the \graphene{} special device to open or create streams, so the file paths or network addresses can be checked against the sandbox rules. The kernel module as the driver of the \graphene{} special device can coexist with any Linux Security Module (LSM), such as AppArmor~\cite{apparmor} or SELinux~\cite{selinux}.


When a new process is launched by the host, it begins execution in a new sandbox.  
Child processes may either inherit their parent's sandbox, or can be started in a separate sandbox---specified by a flag to the host abstractions of process creation.
A parent may specify a subset of its own file system view 
when creating a child, but may not request access to new regions of the host file system. 
%The restrictive policy enforced on the child will be written in a new manifest file generated by the parent, and the policy will be checked by the reference monitor.
The child may also issue an {\tt ioctl} call to 
dynamically detach from the parent's sandbox. The reference monitor prevents byte stream creation across sandboxes.
%among picoprocesses
%that are not in the same sandbox.
%and restricts external connections to remote URIs according to firewall rules in the manifest.
When a process detaches from a sandbox, effectively splitting the sandbox, the host must closes all RPC streams that could bridge the two sandboxes.
\end{comment}



\paragraph{Threat model.}
For most of the \graphene{} hosts (except a SGX host),
an application running inside \graphene{} fully trusts the the library OS,
as well as the host OS or hypervisor
for exporting the host ABI and enforcing security isolation.
the application also trusts other library OS instances in the same sandbox.
However, other applications or library OS instances running in a separate sandbox
will not be trusted.
Other sandboxes on the same host
will be adversary to the hosts and benign application clients,
by exploiting any vulnerabilities on the host ABI, or in the reference monitor.
the \graphene{} design reduces the attack surface between the hosts and the library OS instances, to defend against a malicious application.

%On a host with a reference monitor, the host OS and the reference monitor are both trusted, to mediate all system interfaces used to implement the host ABI. The host must check all access to any abstractions with effects outside of a process's internal state, such as an opened file, or a connected network socket.
%Processes inside the same sandbox mutually trust each other. The adversary can run arbitrary code inside of one or more processes within one or more sandboxes.
%The adversary can control all code in its processes, including the library OS and the host-specific PAL.
%{\tt libLinux} and the \pal{}. 
%We also assume a trusted reference monitor process running on the host kernel that 
%launches \graphene{} applications and mediates all system calls with external effects,\fixmedp{define precisely}

%\graphene{} ensures that %The key security property the \graphene{} design upholds is that 
%the adversary cannot interfere with any victim picoprocesses
%in a separate sandbox.  
%The \graphene{} sandbox design ensures strict isolation: 
%if the only shared kernel abstractions are byte streams and files, 
%and the reference monitor ensures
%there is no writable intersection between sandboxes,
%the adversary cannot interfere with any victim picoprocess.


The threat model of \graphene{} on a SGX host (i.e., \graphenesgx{}) is similar to other hosts, except the applications running on SGX also distrust the host OS, hypervisor, or other system software.
An untrusted OS or hypervisor
holds a wide attack surface to invade applications or VMs,
using Iago attacks~\cite{checkoway13iago}.
The challenges to porting \graphene{} to SGX is not limited to patching the compatibility issues of enclaves, but also requires defending the applications and the library OS against potential Iago attacks.







%%% The only processes allowed to run as standard kernel processes (non-\graphene{}) 
%%% are the reference monitor and
%%% system administration utilities that need more kernel interfaces than the \pal{} ABI provides.
%%% Ensuring that a collaborating picoprocess correctly implements
%%% some function (such as receiving a signal),
%%% as well as preventing exploitation of vulnerabilities in picoprocesses
%%% are beyond the scope of this work.

%\graphene{} reduces the system attack surface of the host, but does not change the size of its
%trusted computing base; however, reducing the effective system call table
%size of a picoprocess does facilitate adoption of a smaller host kernel,
%which we leave for future work.

