\subsection{Page Management}
\label{sec:abi:memory}


\issuedone{1.2.a}{discuss resource management at host level (memory)}
The challenge to defining the host ABI for memory management
is to accommodate different allocation models and granularities of the hosts.
A POSIX-style OS often assumes dynamic allocation with page granularity (the size of a page is normally 4KB);
the assumption is deeply ingrained in the design of page fault handler and page table management
inside an OS like Linux or BSD;
the memory-management component in an OS
is usually low-level and closely interacting with the hardware interface,
to serve the needs of both the OS and applications.
Such an OS design makes it difficult to move memory management
into the library OS, unless using hardware virtualization such as VT.



Linux applications 
are generally developed and compiled under the assumption that the memory is managed
by the OS with page-level granularity.
%generally requires system API
%for allocating, protecting, and deallocating memory at the same granularity.
%A x86 application may require memory allocation to be strictly at the granularity of four-kilobyte pages,
The primary Linux memory API,
including \syscall{mmap}, \syscall{mprotect}, and \syscall{munmap},
allows an application
to arbitrarily create, modify, and destroy VMAs (virtual memory areas),
wholly or partially,
as long as the requested areas align to
4KB.
%Developers can avoid hard-coding the granularity in an application,
%by retrieving the system setting using \syscall{getpagesize}.
Specifically, the Linux dynamic loader (i.e., \code{ld.so}) %, an ubiqutous user-space component in Linux,
uses \syscall{mmap} to map a binary file to a large memory area,
and then divides the mapping into 4KB-aligned code and data segments.
To implement the Linux memory API,
the memory management scheme of the host ABI
must be at least as fine-grained as 4KB pages.


The host ABI for memory management is as follows:
\palcall{VirtMemAlloc} creates an anonymous, non-file memory mapping in a process, similar as \syscall{mmap};
\palcall{VirtMemProtect} changes the read (R), write (W), or execution (X) permission in an address range;
\palcall{VirtMemFree} frees the an address range.




\begin{paldef}
u64  VirtMemAlloc   (u64 expect_addr, u64 size,
                     u16 alloc_type, u16 protect_flags);
bool VirtMemFree    (u64 addr, u64 size);
bool VirtMemProtect (u64 addr, u64 size,
                     u16 protect_flags);
\end{paldef}


The host ABI delegates physical memory management to the host. The division of labor between the library OS and the host is as follows:
the library OS manages only the virtual memory layout of a process;
the host is the one who decides the allocation of physical memory resources, among VMAs of all processes.
The delegation avoids the competition between the host and guest
on managing the physical memory, which is a common issue for virtualization.
For example, a VM may suffer a problem called ``double-paging'' when both the host and guest is trying to swap unused pages out of memory; a VM needs to use techniques like ballooning~\cite{wldspurger02vmware-esx} to subtly coordinate with the host to make paging decisions,
or use paravirtualization~\cite{vmware_vmi}.







