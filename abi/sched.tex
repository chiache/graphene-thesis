\section{Threading}
\label{sec:abi:thread}


\subsection*{Creating a thread}

\begin{paldef}
HANDLE ThreadCreate (void *start, void *arg, uint flags);
void ThreadExit (void);
\end{paldef}




\subsection*{Scheduler}

\begin{paldef}
bool ThreadDelay     (ulong delay_microsec);
void ThreadYield     (void);
void ThreadInterrupt (HANDLE thread_handle);
\end{paldef}



\subsection*{Semaphores}

\begin{paldef}
HANDLE SemaphoreCreate  (uint max_count, uint inital);
void   SemaphoreRelease (HANDLE semaphore_handle);
void   SemaphoreDestroy (HANDLE semaphore_handle);
\end{paldef}


\subsection*{Events}


\begin{paldef}
HANDLE SynchronizationEventCreate (void);
HANDLE NotificationEventCreate    (void);
void EventSet     (HANDLE event_handle);
void EventDestroy (HANDLE event_handle);
\end{paldef}



\subsection*{Polling multiple events}


\begin{paldef}
HANDLE ObjectsWait    (HANDLE *handles, uint nhandles,
                       ulong timeout);
HANDLE StreamGetEvent (HANDLE stream_handle,
                       uint event_flags);
\end{paldef}



\paragraph{Kernel threads vs. user-space threads.}



\section{Processes}
\label{sec:abi:proc}



\begin{paldef}
HANDLE ProcessCreate (const char *manifest,
                      const char **args, uint flags);
void ProcessExit (uint exit_value);
\end{paldef}



\subsection*{Sharing a handle}


\begin{paldef}
void   RpcSendHandle (HANDLE rpc_handle, HANDLE cargo);
HANDLE RpcRecvHandle (HANDLE rpc_handle);
\end{paldef}



\subsection*{Bulk IPC (physical memory store)}


\begin{paldef}
HANDLE PhysicalMemoryStoreOpen (uint index);
\end{paldef}



\begin{paldef}
bool  PhysicalMemoryCommit (HANDLE store_handle,
                            void *addr, ulong size);
void *PhysicalMemoryMap (HANDLE store_handle,
                         void *expect_addr, ulong size,
                         uint protection);
\end{paldef}


\subsection*{Sandboxing}


\begin{paldef}
bool SandboxSet (const char *sandbox_manifest,
                 bool sandbox_rpc);
\end{paldef}