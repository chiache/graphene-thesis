\subsection{Stream I/O}
\label{sec:abi:streams}



\issuedone{1.2.a}{discuss the memory management in the host (I/O)}
An application requires interaction with the world during its execution.
I/O is a common feature of almost every OSes.
The typical I/O needed in an application
can be catagorized into three types:
externalizing data to outside of the machines (i.e., networking);
externalizing data to a permanent store (i.e., storage);
and communicating with other applications running on the same host (i.e., remote-procedure call).
A modern OS may define several abstractions
for each types of I/O; for example, a file in Linux can be read using several system calls,
including \syscall{read}, \syscall{pread}, and \syscall{readv};
RPC in Linux is based on multiple inter-process abstractions,
including pipes, UNIX sockets, and signals.




The host ABI
encapsulates I/O as three different types of byte streams
to send data in and out of applications:
network sockets, regular files, and RPC streams (similar to pipes).
These I/O streams
are created or connected using a URI (unified resource identifier),
a unique name which describes the destinations or resource locations of the I/O streams.
According to the prefix of URI,
the PAL can create either a synchronous I/O stream (e.g., a file or a connected socket)
or named I/O server (e.g., a listening TCP socket).


Modern OSes contain several out-of-band or asynchronous I/O abstractions, to improve the latency or CPU idle time
when polling I/O streams.
Although using out-of-band or asynchronous I/O is beneficial for application performance,
providing these I/O features can be challenging for a host.
Therefore, in \graphene{}, the host ABI restricts I/O abstractions to only synchronous stream I/O.



The host ABI for stream I/O presents a simplified, {\b POSIX file system}.
A POSIX file system
encapsulates I/O abstractions,
including files, sockets, pipes, and even character devices,
in the file system API.
The host ABI contains several functions
which resemble the POSIX API:
\palcall{StreamOpen}, \palcall{StreamRead}, and \palcall{StreamWrite}
are similar to \syscall{open}, \syscall{read}, and \syscall{write} in behavior, with a simplified, explicit semantic;
\palcall{StreamMap} is equivalent to \syscall{mmap} with a \code{MAP\_FILE} flag, mapping a regular file in the process memory. %, for reading or writing data.
\palcall{StreamAttrQuery} and \palcall{StreamAttrQuerybyHandle}
return file and I/O metadata
as \syscall{stat} and \syscall{fstat} do;
The POSIX-style functions simplify the porting of the host ABI
on hosts with a similar specification.






\subsubsection*{Opening or creating an I/O stream}




\begin{paldef}
HANDLE StreamOpen (const char *stream_uri,
                   uint access_flags, uint share_flags,
                   uint create_flags, uint options);
\end{paldef}



Unlike \syscall{open}, \palcall{StreamOpen} uses a URI (uniform resource identifier), for specifying the I/O stream.
An URI identifies both the type of I/O and the distination or location of the I/O stream.
The type of a I/O stream is determined by URI prefix.
The host ABI accepts the following URI prefixes:



\begin{compactitem}

\item \palkeyword{file:[path]}: A regular file mapped from the host file system. The file is located by a file path on the host. The file path can be either an absolute path from the root the host file system, or a relative path from the current working directory on the host.

\item \palkeyword{tcp:[address]:[port]} or \palkeyword{udp:[address]:[port]}: A TCP or UDP connection to a remote socket, identified by a IPv4 or IPv6 address and a listening port. The TCP connection exists until it is teared down by the both parties.

\item \palkeyword{tcp.srv:[address]:[port]} or \palkeyword{udp.srv:[address]:[port]}: A TCP or UDP server waiting for remote connections, bound on a IPv4 or IPv6 address and an idle port.

\item \palkeyword{pipe.srv:[name]} or \palkeyword{pipe:[name]}: A named RPC stream.
The stream can be either a server which awaits incoming connection from other processes,
or a client to an existing server.

\end{compactitem}



Besides the abstraction,
\palcall{StreamOpen}
also inherits similar definitions of function arguments,
including \palkeyword{access_flags}, \palkeyword{share_flags}, \palkeyword{create_flags}, and \palkeyword{options},
from the POSIX-style \syscall{open}.
%also inherit similar meanings from the options of \syscall{open}.
These arguments specify the access type, file permission, creation mode, and other miscellaneous options of the I/O streams:
for example, the access type can be specified as readable or writable,
and the creation mode can be either explicit or implicit.
An important concern is the choice of file permission (specified by \palkeyword{share_flags}), since the host ABI does not expose user credentials
from the host.
Setting the file permission in the host
is mostly a usability feature: 
an application can run more smoothly if some file permissions are externalized.
For example, a compilor can create an executable with the execution permission, so that the consecutive building script can run the executable.
The host ABI also externalizes the file permission
which specifies specify whether a file can be shared with other applications.


\palcall{StreamOpen} returns a {\bf stream handle}. A stream handle is similar to a file descriptor in the POSIX API,
but defined as a pointer to a data structure containing the stream information.
The internal structure of a stream handle is up to the I/O stream type and the implementation of each PAL;
a library OS is supposed to reference a stream handle
only as an identifier.




\subsubsection*{Reading or writing an I/O stream}



\begin{paldef}
ulong StreamRead  (HANDLE stream_handle, ulong offset,
                   ulong size, void *buffer);
ulong StreamWrite (HANDLE stream_handle, ulong offset,
                   ulong size, const void *buffer);
void *StreamMap   (HANDLE stream_handle,
                   void *expect_addr, uint protection,
                   ulong offset, ulong size);
\end{paldef}



The host ABI features include synchronously reading and writing data over an I/O stream.
The behavior of \palcall{StreamRead} and \palcall{StreamWrite} is slightly different between a file stream and other type of stream:
when reading or writing a file stream, \palcall{StreamRead} and \palcall{StreamWrite} accesses the file at a specific offset from the beginning of the file;
otherwise, when accessing a network or RPC stream,
the argument \palkeyword{offset} is ignored, and thus the ABI works similar to \syscall{read} and \syscall{write}.
The design is to keep the stream handle stateless inside the PAL,
for cleanly migrating a library OS.
Since the library OS is responsible of maintaining the offset of a file descriptor,
a library OS instance can be easily detach from a PAL,
by simply ``invalidating'' a stream handle;
the library OS should be able to always reopen the stream after migration,
or after a failure of accessing a stream handle,
to recover the state of an I/O stream.



\palcall{StreamMap} maps a file to an address in the memory,
for either reading or writing data.
\palcall{StreamMap} is used to create a local copy of a file (given permission \palkeyword{WRITE_COPY}),
or a pass-through mapping of a file
which will share file updates with other processes which open the same file.
However, the challenge to implementing this behavior
is to externalize the latest file state
written by the application,
on a host which disallows file-backed memory.
For example, in a SGX enclave, all memory will have to be private memory,
to be individually encrypted by the CPU.
For a host which doesn't support pass-through file mappings,
\palcall{StreamMap}
can only guarantee writing out
the latest file state to the disk when the memory is unmapped, using \palcall{VirtMemFree}.



Another challenge in the library OS, regarding I/O streams,
is to support asynchronously I/O, or peeping data received over a network or RPC stream.
To implement the full Linux I/O features,
the library OS must emulate asynchronous I/O,
using the synchronous
\palcall{StreamRead} and \palcall{StreamWrite}.
The emulation requires opening the I/O stream in a non-blocking mode,
and polling the stream handle before reading or writing data.
The library OS can also buffer the data being read or written over a stream,
as long as the buffered state is coordinated over every processes
which share the same stream.



\paragraph{Alternative.}
An alternative strategy is to define a host ABI with asynchronous I/O,
which is the design choice taken by Bascule~\cite{baumann13bascule}.
An asynchronous I/O ABI can be potentially
more flexible for implementing the library OS features,
as it can emulate both synchronous and asynchronous behaviors
without buffering.
The only reason that we choose synchronous over asynchronous I/O
in the host ABI is to reduce the porting effort,
especially for a host which lacks
asynchronous I/O features.



\subsubsection*{Listening on a server}


\begin{paldef}
HANDLE StreamWaitforClient (HANDLE stream_handle);
\end{paldef} 

Besides the I/O streams which can be directly read or written,
the host ABI also supports creation
of I/O stream server, which can be
connected from another process (to a RPC stream server), or another host (to a network server), as a client of the server.
An I/O stream server cannot be accessed by \palcall{StreamWrite} or \palcall{StreamRead};
instead, the I/O stream server has to block until a client
connects the server, using \palcall{StreamWaitForClient}.
\palcall{StreamWaitForClient} will return a stream handle, which represents a connection with the client.
Other implementation
is up to the host: for example,
the host may decide a maximal number of incoming connections to buffer.









\subsubsection*{Querying stream metadata}

The host ABI features also include retrieving the metadata of an I/O stream.
The retrieval of metadata is not limited to files,
but also network sockets and RPC streams, to query the information regarding the streams.
An example of the stream metadata is the address of a network stream;
when a network stream is created,
the host may randomly determine a local, temporary port to identify the connection;
the POSIX API
reveals the local port number
to the applications,
using \syscall{getsockname}.
Other stream metadata required by Linux or POSIX functionality
includes the total bytes written over an I/O stream, and the permission to sharing an I/O stream with other applications.



The host ABI includes two functions for querying stream metadata:

\begin{paldef}
bool StreamAttrQuerybyHandle (HANDLE stream_handle,
                              STREAM_ATTRS attrs);
bool StreamAttrQuery (const char *stream_uri,
                      STREAM_ATTRS attrs);

\end{paldef}

Both functions fill out a data structure given by the library OS,
with metadata regarding an I/O stream
identified by either a stream handle or a URI.
Keeping both functions can be convenient for the library OS to query a file without creating a stream handle;
however, we can always consolidate the host ABI
with only \palcall{StreamAttrQuerybyHandle},
because \palcall{StreamAttrQuery} can be replaced by \palcall{StreamAttrQuerybyHandle}
after \palcall{StreamOpen}.


To complete the library OS implementation, \graphene{} introduces a new function,
\palcall{StreamAttrSetByHandle},
for changing the metadata of an I/O stream.
The main reason for changing metadata
is to configure a network or RPC stream with several device-specific options,
such as the number of lingering connections,
or enabling the TCP keepalive feature.









\begin{paldef}
bool StreamAttrSetbyHandle (HANDLE stream_handle,
                            STREAM_ATTRS attrs);
\end{paldef}


\subsubsection*{Truncating a file or flushing a stream}


\begin{paldef}
bool StreamSetLength (HANDLE stream_handle, ulong size);
void treamFlush (HANDLE stream_handle);
\end{paldef}


To externalize the change to an I/O stream, the library OS must ensure a file is truncated to the right length (using \palcall{StreamSetLength}), or a network or RPC Stream has flushed the host buffer (using \palcall{StreamFlush}).
Both functions are private to a process; if multiple processes try
to set the file length or flush a stream at the same time, one of the function calls may be ignored by the host.






%\subsection*{\graphene{}-specific stream I/O features}

%\begin{paldef}
%void StreamDelete (HANDLE stream_handle, uint direction);
%\end{paldef}



\paragraph{Directories.}
A POSIX file system contain a hierarchy of directories
containing files and subdirectories.
The file I/O in POSIX requires listing the entries in a directory;
a POSIX function, \syscall{readdir}, returns a list of file and subdirectory names
in a directory.
In \graphene{}, we face a decision of whether to include directory I/O
in the host ABI.
An option is to maintain a local file in each directory
to store a list of file and subdirectory names;
however, this solution will requires maintaining the list whenever a new file or subdirectory is created.
Therfore, we extend the host ABI,
to allow opening a directory as a stream handle.
The library OS can read a list of file and subdirectory names from a directory stream handle,
generated by the hosts.




\paragraph{Character devices.}
The host ABI also supports reading or writing data over a character device, including a terminal.
A terminal can be connected as a stream handle,
using a special URI called \palkeyword{dev:tty}.
Other character devices include the debug stream of a process (the URI is \palkeyword{dev:debug}),
equivalent to writing to \code{stderr} in POSIX.




