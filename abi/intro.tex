This chapter describes the formal definition of the \graphene{} host ABI, and 
the design principles behind the definition, for both the simplicity of porting the host ABI to a new host, and the sufficiency of the host ABI for running a library OS with a rich of Linux functionality.






\section{Defining the host ABI}


\begin{comment}
This chapter describes the formal definition of the host ABI, and discusses the rationale behind the definition, based on the design principles of \graphene{}.
%The host ABI
%is designed to be simple enough to port to a new host,
%and sufficient
The host ABI is a key component
to the \graphene{} design,
to simplify the OS development effort for achieving or restoring compatibility.
%, which reduces the porting effort for reusing existing applications. 
%porting effort of a full-featured library OS, in order to reuse Linux applications.
%The host ABI virtualizes the basic OS functions for implementing the necessary Linux personality
%inside the library OS.
%The definition of the host ABI determines the complexity of porting,
%as well as the performance overheads and resource costs for running the library OS.
%The concept of the host ABI is to reduce the porting effort,
%to simply implementing a small set of virtualized, basic OS functions.
%The functions included in the current \graphene{} host ABI are mostly direct mappings to 
%The definition of the host ABI directly affects the development of the library OS, as well as  the complexity of implementing a host-specific platform adaption layer (PAL).
%The host ABI restricts the interaction between the library OS and the hosts, and thus impacts the performance and security isolation of the library OS.
%\graphene{} restricts the interaction between the library OS and the hosts
%to the host ABI,
%which is much smaller than the Linux system call table
%and much easier to port.
%By simply porting the host ABI to a new host,
%OS developers can virtualize and reuse the same library OS for running
%applications without modifications.
%The host ABI is a layer for virtualizing the system call implementation,
%without complicating the porting of existing applications to innovative host OSes or hardware platforms.
This chapter shows how to select the host ABI as a ``pinch point'' in a Linux-compatible OS, to virtualize OS components into the user space.
\end{comment}




The definition of the host ABI for a library OS
is equivalent to finding a new, narrowed boundary inside an OS for partitioning.
The host ABI partitions
high-level, host-independent OS components (e.g., system calls, namespaces), into 
a dynamically-linked library OS in the user space.
%, as a dynamically-linked library which can be deployed
%to various hosts.
The rationale behind the decision of partitioning the OS is based on the fact that not every OS component is equally important to achieving compatibility, for applications which need to be ported across hosts.
Specifically, drivers (e.g., drivers for file systems, block devices, or network cards)
in the Linux kernels are usually encapsulated under a virtualized, in-kernel interface (e.g., the Linux virtual file system),
to simplify the development of the rest of the kernel.
The goal of the host ABI in \graphene{} is to declare a similar, but more ubiquitous virtual interface,
which encapsulates the drivers and hardware-interfacing components
in an OS or a hypervisor,
to isolate the host distinctions from the library OS.







At a high level,  the host ABI is comparable to a virtual hardware interface to VMs.
A library OS has many traits similar to a VM,

including an isolated, guest OS view inside the VM, sandboxing at both application and OS level, and migration of a whole guest OS.
Due to the similarity between a library OS and a VM,
many characteristics of a virtual hardware interface between a hypervisor and a VM
are useful in defining the host ABI
for a library OS.
For example, for the convenience of migrating a whole VM,
a virtual hardware interface is mostly stateless to both the host CPUs and the hypervisors.
\graphene{} adopts the idea of a stateless host interface,
and designs every function 



para-virtualization solution (e.g., Xen) can deduplicate OS components, such as  schedulers and page fault handlers, between a host and a guest,
by modifying the guest OS to make hypercalls into the hypervisor.




%layer, which defines the entire host features
%available for implementing the library OS.
%The traditional virtual machines reuse unmodified OS kernels on a virtual hardware interface.
%Unlike a virtual machine,
%the host ABI partitions OS components into the library OS, and retains only a set of basic OS functions to interact with the hosts.
%The functions defined in the host ABI
%are either API for requesting hardware resources, or convenient features, such as scheduling primitives, which commonly exist in many OSes.
%%The functions in the host ABIs are similar to
%%the UNIX-style API, or a small portion of POSIX,
%The host ABI is selected as a pinch point for OS virtualization,
%to recycle the virtualized Linux system call implementation, and to harvest the existing host OS functionality for porting the host ABI. 
%%as a leverage point for harvesting the OS functionality implemented on the hosts.

%The \graphene{} host ABI defines a set of {\em functions}, similar to the API of UNIX or POSIX.
%The functions are directly called by the library OS, along with the arguments given either in the registers or on the stack.
%A host-specific \graphene{} loader is responsible for resolving the linking, from the library OS to the host ABI.


\section{Formal Definition}


\subsection{Calling conventions and data structures}


The formal definition of the host ABI assumes that 
the library OS accesses the host ABI as function calls.



%with dynamic linking initialized at the creation of each process (or picoprocess).
%The platform adaption layers (PALs)
%are responsible for
%resolving the calling addresses inside the library OS, and passing the function arguments and return values in and out of the host ABI.



The host ABI follows the Linux calling convention,
which, on the x86 architecture, passes function arguments in general-purpose registers (i.e., \code{rdi}, \code{rsi}, \code{rdx}, \code{rcx}, \code{r8}, and \code{r9}).
Moreover, the host ABI assumes the library OS is compiled into a ELF binary, and includes a simplified dynamic-loading feature for loading the code of the library OS.
The choice of calling convention is based on
the applications which \graphene{} has targeted---unmodified Linux binaries compiled in the ELF format.
Using the Linux calling convention for the library OS
improve the opportunity of leveraging compiler optimizations for symbol resolution (e.g., using hashing), or even statically compiling an application with the library OS. 


%If the library OS and the hosts share the same calling convention, the PAL can directly call
%the host ABI, without any redirection.
%For other hosts,
% that do not share the calling convention with the library OS,
%such as OSX and Windows, the PALs redirect
%the function arguments to the correct registers or offsets on the stack frames assigned by the calling convention.
%Dynamic linking is beneficial for
%building a pluggable, host-independent library OS binary, and leveraging the compiler optimizations across the host ABI.





%By definition, the host ABI is limited to the OS abstractions to the local process.

%Most functions in the host ABI
%only have local effect to a picoprocess.
%Using the host ABI, the library OS can  llocate a memory region inside the current picoprocess, or create a handle that is only accessible by the current picoprocess.
%Only functions related with stream I/O
%can share OS resources with other picoprocesses, such as writing to the same file, sharing a network sockets, or connecting through a local RPC (remote-procedure call) stream.



