This chapter describes the formal definition of the host ABI.
The host ABI contains a simplified specification defining which OS and hardware abstractions should be implemented by the hosts. %, in order to implement the library OS.
The host ABI is also a specification of PALs (platform adaption layers).
%which translates the host ABI
%to host OS features.
This chapter shows how to define and extend a host ABI,
based on design principles of \graphene{}. %, including simplicity and sufficiency.
%and security isolation.
%determine the definition of the host ABI,
%as a guideline to adding host features.
%with new abstractions.


%and 
%the design principles behind the definition, for both the simplicity of porting, and the sufficiency of implementing Linux functionality.













%ion solution (e.g., Xen) can deduplicate OS components, such as  schedulers and page fault handlers, between a host and a guest,
%by modifying the guest OS to make hypercalls into the hypervisor.



%The strategies for defining the host ABI in \graphene{}
%can be summarized as follows:
%First, \graphene{} inherits most host OS functions from \drawbridge{}~\cite{porter11drawbridge},
%with minor extensions. % for implementing Linux system calls.
%\graphene{} and \drawbridge{} share a similar motivation: reusing unmodified applications across host platforms.
%%\drawbridge{} 
%%tries to reuse Windows code
%%in most of its library OS implementation.
%%As a result, most functions defined in the \drawbridge{} host ABI have certain level of similarity with 
%%the Windows API.
%%such as the scheduling primitives.
%%\drawbridge{} makes the decision
%%primarily for maximally reusing the Windows OS code in the library OS.
%Although inheriting the host ABI from \drawbridge{} 
%is mostly an engineering decision
%in \graphene{},
%this strategy covers the typical UNIX-style OS features,
%with a definition largely distinct from Linux system calls in style.
%
%
%
%Second,
%\graphene{} adds several host functions for
%extending the library OS features which are unique to Linux.
%For example, 
%use of x86 segment registers (FS/GS) is necessary for Linux applications hard-coded with
%direct TLS (thread-local storage) references.
%The segment registers can only be written in ring 0;
%although a user-ring instruction, \code{WRFSGSBASE}, can also write to the registers,
%the feature is not opt-in on x86.
%Therefore, adding a 










%layer, which defines the entire host features
%available for implementing the library OS.
%The traditional virtual machines reuse unmodified OS kernels on a virtual hardware interface.
%Unlike a virtual machine,
%the host ABI partitions OS components into the library OS, and retains only a set of basic OS functions to interact with the hosts.
%The functions defined in the host ABI
%are either API for requesting hardware resources, or convenient features, such as scheduling primitives, which commonly exist in many OSes.
%%The functions in the host ABIs are similar to
%%the UNIX-style API, or a small portion of POSIX,
%The host ABI is selected as a pinch point for OS virtualization,
%to recycle the virtualized Linux system call implementation, and to harvest the existing host OS functionality for porting the host ABI. 
%%as a leverage point for harvesting the OS functionality implemented on the hosts.

%The \graphene{} host ABI defines a set of {\em functions}, similar to the API of UNIX or POSIX.
%The functions are directly called by the library OS, along with the arguments given either in the registers or on the stack.
%A host-specific \graphene{} loader is responsible for resolving the linking, from the library OS to the host ABI.


%\section{Formal Definition}
%
%
%This section formally defines the calling convention, data types, and functions
%in the host ABI.
%The host ABI
%specifies the scope of PAL development,
%and the host features required by the library OS.
%%The definition specifies the research problem
%%in the development of \graphene{},
%%which is the translation between the Linux system interface, the host ABI, and various host interfaces.
%



\section{Subroutine Calling Convention}







The formal definition of the host ABI assumes that 
the library OS accesses the host ABI as function calls.



%with dynamic linking initialized at the creation of each process (or picoprocess).
%The platform adaption layers (PALs)
%are responsible for
%resolving the calling addresses inside the library OS, and passing the function arguments and return values in and out of the host ABI.



The host ABI follows the Linux calling convention,
which, on the x86 architecture, passes function arguments in general-purpose registers (i.e., \code{rdi}, \code{rsi}, \code{rdx}, \code{rcx}, \code{r8}, and \code{r9}).
Moreover, the host ABI assumes the library OS is compiled into a ELF binary, and includes a simplified dynamic-loading feature for loading the code of the library OS.
The choice of calling convention is based on
the applications which \graphene{} has targeted---unmodified Linux binaries compiled in the ELF format.
Using the Linux calling convention for the library OS
improve the opportunity of leveraging compiler optimizations for symbol resolution (e.g., using hashing), or even statically compiling an application with the library OS. 


%If the library OS and the hosts share the same calling convention, the PAL can directly call
%the host ABI, without any redirection.
%For other hosts,
% that do not share the calling convention with the library OS,
%such as OSX and Windows, the PALs redirect
%the function arguments to the correct registers or offsets on the stack frames assigned by the calling convention.
%Dynamic linking is beneficial for
%building a pluggable, host-independent library OS binary, and leveraging the compiler optimizations across the host ABI.





%By definition, the host ABI is limited to the OS abstractions to the local process.

%Most functions in the host ABI
%only have local effect to a picoprocess.
%Using the host ABI, the library OS can  llocate a memory region inside the current picoprocess, or create a handle that is only accessible by the current picoprocess.
%Only functions related with stream I/O
%can share OS resources with other picoprocesses, such as writing to the same file, sharing a network sockets, or connecting through a local RPC (remote-procedure call) stream.




