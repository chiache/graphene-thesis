\chapter{Introduction}
\label{chap:intro}

Operating systems simplify programming an application utilizing different hardware.
A UNIX-style OS~\cite{ritchie74unix}
encapsulates hardware resources using a system interface such as a system call able.
Without a system interface,
developers will have to program against hardware interfaces defined by manufacturers.
Programming against bare hardware
creates applications that are restricted to 
specific hardware.
Operating systems allow application developers to program against a consistent, hardware-independent
system interface, %with a consistent view of system features,
%A system interface must be independent from the idiosyncrasy of hardware,
so that the applications can be portable
across hardware configurations.







%, and allows applications to be widely deployed on different platforms.
%an OS can be a more powerful ``extended machine'',
%which is more feature-rich and homogeneous than the bare hardware~\cite{dhamdhere2007os-textbook}.
%The purpose of an extended machine
%is to provide a consistent view for all the system features,
%which are independent from the choice of hardware.
%available for programming.
%presented by the system interface
%is independent from the physical machines running the OS.
%for applications to be programmed with.
%compared with the physical machines for running the OS.
%The value of a portable application is to be deployed and reused
%upon different hardware options, such as CPU models, memories, and I/O devices, as long as the system interface encapsulates the hardware.
%encapsulated by the OS.
%different encapsulated hardware options, including CPU models, memories, and I/O devices. 
%upon a series of continuously-developed hardware,
%including CPUs, memories, and I/O devices.
%Application portability requires an OS to export a system interface
%independent from hardware configurations,
%such as different CPU models, memory of different capacity, and various I/O devices.
%The only exception is the portability across CPU architectures,
%Otherwise, application developers would expect an application, built without dependency to %specific hardware, to be reusable in an OS regardless of what hardware users choose.
%The same assumption on application portability has been shared among
%Linux~\cite{linux-standard-base}, Windows~\cite{win-api}, or POSIX~\cite{ieee-posix}.






%to facilitate application programming.
%to make applications adaptable and widely distributable.
%facilitate the development of an portable application.
%share the merit of application portability.




An application developed upon a system interface subjects to a different property as compatibility.
%for a specific OS depends on a system interface
%to remain compatible.
{\bf Compatibility} of an OS can be
defined as 
the ability to reproduce a system interface which satisfies the hard-coded requirements of an application.
%Application programming models are often influenced by the definition of system interface.
%A system interface contains
%a set of OS functions that applications
%call to describe the order and condition of requesting OS services.
Since a majority of applications are compiled into native code,
usage of system interfaces
is scattered around application binaries
and does not easily change unless modifying source code.
%The development of a fully-compiled application (not as a script or intermediate code)
%includes hard-coding the usage of a system interface
%in the binaries.
%\polish{Application developers make the decisions of embedding the requests and parameters of interacting with a system interface inside of an application.}
%A fully-compiled application is mostly hard-coded with the usage of a system interface
%The programming of a system interface requires
%hard-coding the intention and condition of requesting OS services
%in the application code.
To accommodate application binaries,
OS developers maintain a common goal as keeping system interfaces
compatible across OS versions.
%If a milestone of OS development involves modifying a part of the system interface,
%an application becomes obsolete
%if it contains outdated system interface specifications.
%due to mismatching with the latest definition.
Compatibility is also a goal for less widely-used OSes; for instance, FreeBSD emulates Linux system calls to
reuse the more well-adopted Linux applications.
%Although compilers and libraries can reconstruct or recast some OS functions,
%a principle-level or assumption-level change in the system interface
%would still be difficult to recover.
%by translating either at compile time or through a thin library.
%The common practice in OS development is to preserve
%the whole system interface,
%as application developers previously observe when building an application.
For generality, OS developers tends to preserve every old system interfaces
to maintain compatibility for exiting application binaries.

%is generally known as compatibility.






%Compatibility is broken when an OS developer decides to extend the system interface,
%in order to adopt new hardware.
%If a system interface is extended for a new hardware,
%existing applications need to be reprogrammed accordingly, using the latest system interface.
%Extensions to a system interface are usually in the form of \syscall{ioctl} operations in a POSIX-style OS,
%or new system call options such as the \code{MAP\_HUGETLB} flags for \syscall{mmap}.
%Unless an OS can be transparently extended for a new hardware,
%%be completely transparent to applications,
%users will have to tolerate the limitation that utilization of the hardware in applications
%will lag behind deployment,
%because of the additional porting efforts.



However, the trend of hardware development
challenges the goal of maintaining OS compatibility.
%An OS needs to be be continuously extended to utilize new hardware.
The majority of new hardware follow semantics of predecessors
and requires no changes to existing system interfaces.
However, more cutting-edge hardware tend to leak out of
the typical abstractions
encapsulated by OSes;
%and thus demands extra attention for adoption.}
%The challenges emerge as more ground-breaking hardware technologies
%have been released in the industry.
\issuedone{1.2.b}{Specify SGX as a motivating example}
one example is SGX (software guard extensions)~\cite{intelsgx}
on recent Intel CPUs.
SGX protects an application
with integrity and confidentiality, without trusting other system components 
such as OSes, hypervisors, and system software.
Although an SGX application
may still utilize system interfaces for OS functionality
such as file systems and networking, the application does not assume
the OS to be reliable.
Therefore, SGX raises several compatibility issues to
existing system interfaces,
including the challenges of checking system interface results
on an untrusted OS.
%however, SGX also raises several compatibility issues, including reverting the trusted nature of OS services.
%and restricting the sharing of isolated application memory~\cite{shinde17panoply}.
Other examples can be found among research-type architectures,
such as an asymmetric multi-processing architectures
without inter-connected memory~\cite{gschwind2007,cascaval2002evaluation},
which challenges inter-process coordination.
%which complicates the implementation of state-sharing, multi-process abstractions. 
%Despite the benefits of SGX on application protection,
%SGX requires changing the applications to defend against malicious OS services,
%and to work around several compatibility issues of the restricted ISA of SGX (more details discussed in Section~\ref{sec:intro:sgx}).
%Especially, the size and subtlety of the Linux or Windows system interface
%makes it unsuitable for adopting applications to SGX~\cite{checkoway13iago}, because SGX has fundamentally changed the nature of OS services.
%Several recent publications mitigate part of the compatibility issue for deploying applications on SGX~\cite{baumann14haven,osdi16scone,shinde17panoply}.
%This thesis
%uses SGX as a strong motivating example (see Section~\ref{sec:intro:sgx}),
%because SGX fundamentally reverses a critical OS assumption, and causes a combination of compatibility and security problems.
%SGX shows that compatibility issues can be distraction to innovations.
As more disruptive hardware
may emerge in the future, OS developers should
gradually promote new system interfaces which encapsulate latest hardware semantics; simultaneously, existing applications require timely solutions to resolve urgent compatibility issues on specific hardware.


Empirically, compatibility has caused struggles in OS development,
especially when API changes are demanded.
%An system interface may contain outdated specifications of OS features and application programming interfaces (APIs);
%~\polish{however, OS developers generally avoid modifying the system interface,
%despite of missed opportunities to
%improving both OS and application sides.}
For instance, Linux and similar OSes
introduce system calls such as \syscall{openat} as a version of \syscall{open}
without TOCTOU (time-to-check-to-time-to-use)
vulnerabilities.
Unfortunately,
to full replace the original \syscall{open}, developers needs to modify every applications, otherwise Linux can never deprecate
the unsafe version.
%would be a painful and lengthy process,
%wherein every applications have to be reprogrammed accordingly.
%until the process finally expires.
%Imaginably, a more large-scale modification of the system interface
%may be catastrophic.
At a larger scale, an early version of Windows Vista introduces
%Moreover, if a system interface is changed on a large scale,
%the result may be catastrophic:
%a well-known example is an early version of Windows Vista,
%codenamed ``Longhorn'',
a brand-new user interface API
and file system,
but ends up losing popularity due to compatibility-related complaints~\cite{spolsky04microsoft-api-war}.
Because users prefer to use an application or a system
that hasn't broke,
earlier versions of OSes, such as Windows XP, remain popular even after end-of-service.
%Maintaining system interface compatibility is generally a responsibility of OS developers;
%while extending an OS for expanding the portability of applications
%on new hardware.
%Despite the OS extensions for future hardware,
%the system interface has to stay compatible with existing applications.
%Especially, OS developers may face compatibility issues
%when the adopted hardware leaks out of the abstractions encapsulated by the current system interface.
%Many examples show that
%These are examples that compatibility restrictions
%hinder OS development.
%\keepthis{In general, OS developers treat compatibility as an important factor to the usability of a system,
%but also an unwelcome distraction in the early stage of innovation.}


There are practical reasons
for an OS to maintain compatibility for unmodified applications.
The development of a commercial application
requires a thorough process of testing and code inspection to ensure correctness and robustness.
Modifying an application for new system interfaces can be a risk to stability.
Moreover, third parties cannot port a proprietary software to new system interfaces even if they are motivated to do so.
These dilemmas call for a solution
to mitigate 
the compatibility issues for 
unmodified applications.





\issuedone{1.1.b}{Specify the problem as reducing the gap of interface idiosyncrasy}
This thesis proposes building a compatibility layer
which translates
a legacy system interface to other alternative host interfaces, as a promising solution for supporting unmodified applications.
OS developers are free to redesign
system interfaces
for adopting new hardware or addressing system challenges.
%can't or shouldn't avoid modifying a system interface,
%yet existing application tend to rely on former system interface definitions to remain functional.
A compatibility layer between the application and the OS
can bridge the gap between interfaces.
%system interface definitions, including both the APIs and the nature of OS features.
Take SGX for example;
the compatibility challenges on SGX include
secure dynamic loading,
redirecting system calls to host OSes, and inject security checks against untrusted system call results.
The goal is to reduce the effort of porting a compatibility layer
to any host platforms.
A Linux compatibility layer
potentially contains
hundreds to thousands of system calls, with plenty of control options and corner cases~\cite{linux-man-syscall}.
%developing such a compatibility layer,
%so that maintaining compatibility would not become a burden in OS development and innovation.
%OS developers should not have
%to reimplement every features of a system interface in a compatibility layer;
%A modern OS such as Linux
%can contain up to 
This thesis presents a solution
to building a rich-feature compatibility layer, in which
majority of code does not have to be rewritten when porting to a new host interface.









%%A system interface can contain up to hundreds or thousands of \linuxapi or OS functions, with numerous corner cases and programming options~\cite{ieee-posix, linux-man-syscall}.
%
%%is influenced by the design of plenty of pre-existing hardware,
%%and thus is difficult to change for another disruptive hardware.
%%For example, a monolithic OS, such as Linux or Windows, assumes a unified kernel, which mediates all operations from applications to request hardware resources and abstractions.
%Also, an OS prototype built from scratch
%can redefine a system interface which accommodates a new hardware, or optimizes for it~\cite{baumann09barrelfish,peter14arrakis,belay14ix}.
%%and may require compatibility against deployed applications.
%%often chooses to adopt the system interface of a popular OS standard, such as POSIX or Linux, to reuse applications already under deployment.
%%It is a practical move to implement system interfaces from a popular open OS such a Linux,
%%to demonstrate the benefits of using an OS prototype
%%on running certain native applications.
%%An OS can define a system interface with up to hundreds or thousands of functions~\cite{ieee-posix, linux-man-syscall}. %nearly impossible to fully implement from scratch.
%However, to be compatible with existing applications,
%building a translation or emulation layer for reproducing the former OS behavior and semantic, upon either an adapted system interface or an OS prototype, is still necessary.



Building such a compatibility layer
can benefit from virtualizing 
a part of an OS, or more specifically, API components (e.g., system call table), to user space.
\issuedone{1.2.c}{Discuss library OS vs VM}
Virtualization can preserve these OS components,
using an intermediate interface
exported by the host OS.
For instance, a VM (virtual machine) carries an unmodified OS kernel
as a full-stack compatibility layer.
The intermediate interface for a VM
is a virtual hardware interface,
%A virtual machine conveniently reuses existing OS implementation
%for reproducing the system interface,
facilitated by hardware virtualization~\cite{popek74virtual}
such as Intel VT (virtualization technology)~\cite{VT}.
%Virtualization
A VM can provide full compatibility
by reusing an existing OS implementation.
%as long as the architecture is virtualizable.


An alternative to a VM is
%an alternative to a VM, OS developers can partition an OS, to virtualize only necessary components into a thin compatibility layer}---
a {\bf \libos{}}
~\cite{porter11drawbridge,engler95exokernel,libra,unikernels},
a user-space OS library loaded
inside an application's address space.
%when adopting an innovative hardware or alternative system interface.}
%implementation of compatibility in an OS, in case the OS developers intend to extend the OS for new hardware.
%reducing the difficulty of retaining compatibility
%is to reduce the complexity of system interface which has to be reproduced, to achieve compatibility against existing applications.
%when extending the OS implementation.
The purpose of a \libos{} is to
reproduce the features and API of a system interface on top of a library,
upon a generic host interface.
%inside a user-space, reusable {\em library} that executes upon a virtualized host interface.
%Unlike the virtual hardware interface,
Defining a host interface is for the simplicity of porting.
%of OS development upon each host OS and hardware.
The definition process
is equivalent to
finding a ``pinch point'' inside an OS,
to partition out the high-level, host-independent OS components.
%A library OS can be reused to build a compatibility layer for unmodified applications upon any host,
%as long as the host interface is implemented.
A host interface must be relatively easy to develop,
so that porting the \libos{}
requires less effort than redeveloping
a compatibility layer.


This thesis presents
{\bf \graphene{}},
a library OS for running unmodified applications upon innovative hardware and alternative system interfaces.
\graphene{} reproduce the rich Linux system calls,
for reusing a wide range of commercial software
to benefit highly-customizable server and cloud environments.
A host ABI (application binary interface)
facilitates the
host abstractions for the \libos{},
and is easily ported to different host system interfaces
and hardware platforms. 
This thesis demonstrates the simplicity
by porting the host ABI
to two representative host examples, a Linux kernel and an isolated environment with SGX.
%The \graphene{} library OS
%is developed upon a narrowed host interface, defined as a host ABI (application binary interface),
%to be easily ported to various host options.
%The host ABI isolates the implementation of Linux features and API, from addressing the low-level restriction and idiosyncrasy.
%The strength of \graphene{} is to fine-tune the host ABI,
%to simplify the host development and drop the assumptions on host OSes and hardware.
%So far \graphene{}
%has been targeting several host options,
Other ongoing ports
include alternative kernels, such as Windows, OSX, and FreeBSD, and research-type OSes, such as L4 microkernels~\cite{l4family}, and Barrelfish~\cite{baumann09barrelfish}.



\issuedone{1.2.d}{Specify target applications of Graphene libOS}
The \libos{} approach strikes a better balance % the trade-offs
between simplicity of porting
and sufficiency of compatible OS functionality. % to be compatible against applications.
A study of Linux system interface~\cite{tsai16apistudy}
show that system calls
are not equally important to applications.
%upon different host OSes and hardware.
Applications also
subject to different popularity among users, as shown in
installation statistics~\cite{ubuntu-popularity}.
A portion of Linux system calls are strictly for administrative purposes,
such as configuring Ethernet cards and rebooting the machines,
and are 
exclusively used by
system software such as \code{ifconfig} and \code{reboot}.
%while each host OS is likely to have its own version of system software.
%and each host OS is likely to contain similar tools.
As a result, a \libos{} can selectively implement
system calls
based on importance for applications
with porting value.



\graphene{} primarily targets three types of applications:
(1) server and cloud applications, such as Apache and Lighttpd;
(2) command-line programs, such as Bash and GCC;
(3) language runtimes, such as R, Python, and OpenJDK.
\graphene{}
implements sufficient system calls (\graphenesyscallnum{} out of \linuxsyscallnum{} Linux system calls),
upon a narrowed host ABI containing \palcallnum{} functions.




%This OS design targets on commercial Linux applications used in cloud environment, including server applications, command-line programs, and language runtimes.
%This thesis shows that the defined host ABI is sufficient to implement a rich of OS functionality for reusing the said applications.


%This thesis shows that a library OS can implement a substantial amount of OS features needed by the reused applications,
%and the host ABI can be easily ported to a new physical machine or an alternative OS.
%using a host interface defined with simplicity and minimal assumptions. This \libos{} design, alone with the host interface, is potentially stackable on various operating systems, to benefit both backward and forward compatibility.



%This thesis shows the embodiment of an OS design as the \graphene{} library OS.
%The  library OS can run a wide range of unmodified Linux applications,
%including server-type applications, command-line programs, and language runtimes, on a set of host OSes and hardware platforms.
\graphene{} inherits 
a part of the host ABI from \drawbridge{}~\cite{porter11drawbridge},
a previous library OS developed for reusing 
%which has demonstrated compatibility benefit over
Windows applications.
\drawbridge{} uses the \libos{} as a lightweight VM
to run Windows desktop applications such as in a guest environment.
Running a \libos{} as a partitioned OS component also requires
less memory resource than a full VM,
and thus improve the density of packing guests in a physical machine.
Bascule~\cite{baumann13bascule} later adopts the design
to implement single-process, Linux system calls.
%, and inserting host-level extension layers.
Finally, Haven~\cite{baumann14haven} ports \drawbridge{} to SGX, to shield Windows application from untrusted host OSes.
\graphene{} %extends the concept of previous work
presents solution for running unmodified applications
upon a variety of host OSes and hardware,
and defines a host interface to be both easy to port and sufficient
for developing a rich-feature \libos{}.



%\issue{1.3.a}{Compare Graphene vs Docker}
%Established upon the previous work, 
This thesis has several contributions over previous work.
First, this thesis
defines a host ABI which is easy to port
on new host platform,
by enumerating the porting effort, including translating host system interfaces and enforcing security checks.
Second,
this thesis demonstrates the development
of a \libos{}
using the host ABI,
and presents emulation strategies
for complex Linux features such as multi-process abstractions,
with reasonable overheads and memory footprints.
Third,
this thesis presents a quantitative method of evaluating compatibility
to prioritize system interface emulation
in a \libos{} or a research prototype.
 

%\begin{compactenum}
%\item \graphene{} explores and justifies the feasibility of building a library OS for resolving compatibility issues on various OSes and hardware.
%%(1) Reasoning about the portability and completeness of functionality.
%% of the host ABI and library OS design for both
%\item \graphene{} faithfully implements a rich of native Linux system calls, including several challenging features which are specific to Linux or UNIX,
%such as multi-process abstractions.
%\item \graphene{} shows it possible to engineer a library OS
%with practical performance overhead,
%and memory footprint close to a Linux process.
%\item Comparable to a VM, \graphene{} can enforce strong security isolation
%between mutually-untrusted applications,
%with a narrowed attack surface to the host kernel (more in Section~\ref{sec:intro:security}).
%\end{compactenum}




\section{Motivating examples}

\issuedone{1.1.b}{Adding motivating examples in the intro}
This section shows two examples in which developing a compatible OS for existing applications can be challenging, to motivate the library OS design.


\subsection{Unmodified applications on SGX}
\label{sec:intro:sgx}


%One of the motivating examples, for using \libos{} to improve application compatibility,
%is the support of unmodified Linux application
%on the platform of Intel (SGX)~\cite{intelsgx}.
SGX~\cite{intelsgx} are new extensions to the six-generation Intel CPUs,
%provide the hardware support for trustworthy, isolated execution, as part of the sixth-generation Intel CPU extensions.
%Using SGX, application developers 
which can
protect signed application code from attacks in compromised OSes, hypervisors, and other system software.
In the isolated environment of SGX, or {\bf enclaves}, applications can securely utilize the
resources of an untrusted host,
such as a public cloud machine for rent, or a client machine,
with both confidentiality and integrity.
%By running the application code on SGX, the code has 
%emory state inside of the protected code
%to be signed and encrypted, when the code and data leave the CPU package and are stored in the DRAM or swap device.
SGX also offers attestation for the integrity of remote enclaves, as well as proving the integrity of the Intel CPUs.


%A Linux application running on Intel SGX can receive end-to-end protection from the untrusted OSes, but also no longer have a trustworthy OS to faithfully return correct, benign OS features, such as reading a file or creating a thread.
%The untrusted OS can potentially launch attacks through manipulating  
%valid return values to applications, which are known as the Iago attacks.
%The problem of defending against Iago attacks is that these attacks are hard to predict among all the scenarios and corner cases in the full OS functionality of a modern OS like Linux or Windows, given the complexity of OS semantics and the lack of study on untrusted OSes.
%As a result,
%building an ad hoc compatibility layer to implement and defend OS features for general Linux applications in Intel SGX
%not only is cumbersome but also cannot be properly checked for security.

To utilize SGX, common expectation is that developers have to partition a piece of the application code to run inside an enclave.
The restriction is for both security and simplicity reasons.
The enclave code is mostly statically compiled, for making code verification straightforward.
%and thus is easier to sign and verify.
Development of enclave code also involves removing OS function calls and instructions which are not supported in an enclave.
%If users intend to run an unmodified application, SGX imposes several restrictions on running unmodified applications inside an enclave.
%The restrictions are either imposed by the SGX hardware in the run time, or statically by the official Intel SGX SDK (software development kit).
The restriction on the instructions is also for the clarity of application protection.
For example,
%including \code{cpuid} and \code{rdtsc}, for the clarity of shielding these hardware features.
SGX forbids \code{cpuid} in case of combining with the hardware virtualization (VT),
to avoid trapping to hypervisors.
%, which is untrusted in the threat model of SGX.
SGX also forbids \code{rdtsc}, in order to rule out potential physical attacks on the Time Stamp Counter (TSC). 
%The application developers would have to remove these instructions from the applications in order to run inside an enclave.


\issuedone{1.2.c}{Discuss challenges of SGX shielding}
SGX excludes OS services from the trust model, except functions which can be fully ported to user space (e.g. \syscall{malloc}).
The absence of trusted OS services is an issue for porting any application.
Existing solutions combines a modified C library with applications, to redirect system interfaces
to the untrusted OS~\cite{osdi16scone,shinde17panoply}.
The problem, however, is in checking the results of system interfaces, because the OS is not trusted. % to faithfully implement OS services.
%Checks against simple attacks are possible,
%such as checking if returned pointers are valid to the enclave regions.
%to \syscall{mmap} which points to existing memory regions that can be corrupted or can leak sensitive information
Previous work~\cite{checkoway13iago} shows that
checking untrusted system interface results can be subtle, because the existing system interfaces are not designed for an untrusted or compromised OS.


In summary, the existing porting models of Intel SGX always requires modifying application binaries, and reasoning about the completeness of checking system interfaces.
This thesis argues that, by introducing a library OS into enclaves,
the interaction with the untrusted OS can be restricted to OS services which have clear semantics for checking.
%an narrowed, fixed enclave interface can be defined, to restrict interaction with the untrusted OS to services that can be explicitly checked.
By implementing the host ABI inside an enclave,
users can easily run an unmodified Linux application, such as an Apache server or an OpenJDK runtime,
with a trusted \graphene{} library OS instance.



\subsection{Multi-process applications}
\label{sec:intro:multiproc}


\issuedone{1.3.b}{Using multi-process as a motivating example}
One characteristic of a UNIX program is the opportunity of utilizing multiple processes, created by either \syscall{fork} or \syscall{exec},
to program self-contained sessions or commands in applications.
Especially, \syscall{fork} is an unique feature in UNIX-style OSes, such as Linux and BSD,
to clone a process into another child process, with isolation from the parent.
%mostly with copy-on-write paging.
%The process state can be easily tore down at exit.
The multi-process abstractions are convenient for creating a temporary session for processing incoming requests or commands, and destroying the session without corrupting the parent process.

Between multiple processes, there are several mechanisms of inter-process communication (IPC)  available for programming.
The Linux IPC combines the UNIX System V features, including message queues and semaphores,
and POSIX abstractions, such as signaling and namespaces.
%The implementation of these mechanisms is idiosyncratic to Linux applications, and has to coordinate several global states across all processes.
Figure~\ref{fig:overview:proc-example} shows a code example of
two Linux programs (``\code{sh}'' and ``\code{kill}'')
running in parallel as part of a multi-process application and communicating with signals.
%Signaling between the parent and child processes
%can happen in several occasions, including processes being terminated accidentally or deliberately, and one process calling the \syscall{kill} system call.
The destination of signaling is determined by a unique process identifier (PID)
known by all processes.
These kinds of identifiers or names are globally shared, as part of the POSIX namespaces,
among applications or processes visible to each other.

 

\begin{figure*}
\begin{minipage}[t]{.65\textwidth}
(Parent process: \code{"sh"})
\lstset{basicstyle=\ttfamily\footnotesize,fontadjust=true,breaklines=true}
\begin{lstlisting}
char pid[10], *argv[]={"kill",pid,0};
itoa(getpid(), pid, 10);
if (!fork()) //clone a process
  execv("/bin/kill", argv);
wait(NULL);  //wait for signal
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{.33\textwidth}
(Child process: \code{"kill"})
\lstset{basicstyle=\ttfamily\footnotesize,fontadjust=true,breaklines=true}
\begin{lstlisting}

pid=atoi(argv[1]);
//send a signal
kill(pid, SIGKILL);

\end{lstlisting}
\end{minipage}
\caption{Sample code for Linux applications using process cloning and inter-process communication (IPC).}
\label{fig:overview:proc-example}
\end{figure*}



Implementing IPC mechanisms in an OS used to rely on a coherent kernel space, but can be challenging when an OS makes the opposite assumption.
%Since coordination is necessary for multi-process applications, 
The easiest design is to store the states and namespace in the kernel memory accessible to all processes.
Sharing kernel states, however, is prone to attacks in an OS with process sandboxing,
or in an application
isolated by hardware like Intel SGX.
An isolated OS design tends to avoid sharing a fully-trusted, coherent kernel space shared with other applications.
For example, on SGX, an enclave cannot share trusted memory with other enclaves.
%The only possible solution without introducing more OS functionality into enclaves is to export the encrypted states to the untrusted kernel, which will suffer significant overheads.


Moreover, not all architectures assume inter-connected, coherent memory.
Several recent multi-CPUs architectures choose not to implement memory coherence for simplicity~\cite{gschwind2007,cascaval2002evaluation}.
Barrelfish~\cite{baumann09barrelfish} demonstrates an efficient OS design, called multikernels, which runs distributed OS nodes on CPUs with inter-node coordination by message passing.
The distributed OS design resonates with the \graphene{} library OS, which uses RPC (remote procedure call) streams to implement multi-process abstractions.
%\graphene{} can be a flexible option for building up compatibility against multi-process applications.
Since \graphene{} does not assume a coherent kernel space, it can be a flexible option
for porting multi-process applications to a variety of OSes and architectures.



\section{Security isolation}
\label{sec:intro:security}

\issue{1.1.d}{Separate the motivation for security isolation}




\section{Evaluating API compatibility}


\rewrite{
This thesis studies the compatibility requirement in Linux and POSIX
from the perspectives of applications and users.
The study begins with building a metric for compatibility,
weighted by the API usage in applications,
and application importance (or popularity).
%for measuring and implementing compatibility. The design principle applies to either a commodity OS, a newly-built OS prototype, or the \graphene{} library OS.
%This thesis shows that the compatibility against the existing applications, in an OS, can be measured and incrementally improved by scientific approach.
%Using a metric that is weighted by the usage of system interfaces in a large sample of commonly used applications, as well as the popularity of the sampled applications,
Using the metric,
OS developers can quantitatively determine the priority in implementing a system interface,
and evaluate the developed results.
The study shows that most applications do not require
half of the Linux system calls,
which are either for administrative use (e.g., halting the machine), or unpopular among applications.
}


\section{Summary}

This thesis contributes a library OS design, called \graphene{},
which demonstrates the benefits on reusing unmodified Linux applications, upon new hardware or OS prototypes.
Compared with ad-hoc translation layers,
a library OS with a rich of Linux functionality (\graphenesyscallnum{} system calls) can be reused on various host platforms, as an adaptable layer with compatibility.
\graphene{} can adapt to the restrictions and
limited hardware abstractions on a host, with acceptable performance and memory footprint.
This thesis further reasons about the sufficiency of a library OS
for running frequently-reused applications. The reasoning is based on a metric which can evaluate the partial compatibility of a system interface.
\graphene{} prioritizes indispensable system calls over administrative or unpopular features,
to reuse a wide range of applications, from server applications to language runtimes.


\paragraph{Previous publications.}
The initial design of the \graphene{} library OS is presented in \cite{tsai14graphene}, which emphasizes on security isolation, between mutually-untrusted applications.
A later publication~\cite{tsai17graphene-sgx} focuses on porting the host ABI
to Intel SGX, and demonstrates the security benefit 
over a thin redirection layer, and the usability feature to run unmodified applications.
\cite{tsai16apistudy} presents the compatibility metrics for compatibility,
with a study of the Linux API usage among Ubuntu users and applications.

\section{Organization}

The rest of this thesis is organized as follows:
Chapter~\ref{chap:overview} describes the overview of Graphene (including the host ABI and the library OS) and the design principles behind the implementation.
Chapter~\ref{chap:abi} formally defines the host ABI, and provides a specification of the host-specific PAL (platform adaption layer).
Chapter~\ref{chap:libos} discusses the library OS in details.
Chapter~\ref{chap:linux} describes the PAL on Linux, as an example of implementing the host ABI and security isolation between library OS instances.
Chapter~\ref{chap:sgx} discusses SGX-specific challenges to application porting, and the PAL implementation inside a SGX enclave.
Chapter~\ref{chap:eval} evaluates the performance and memory footprint of \graphene{} and \graphenesgx{},
and presents a security study.
Chapter~\ref{chap:metric} presents a quantitative metric for compatibility,
to evaluate the completeness of Linux functionality in \graphene{}.
Chapter~\ref{chap:study} presets a study of the Linux API importance, to give an insight about prioritizing API implementation.
%uses the metrics of API importance, to study the usage of Linux interfaces in applications.
Chapter~\ref{chap:related} discusses the related work.
Chapter~\ref{chap:conclusion} concludes the thesis.
