\paperchapter{Introduction}
\label{chap:intro}

Operating systems simplify programming of an application to utilize hardware with different interfaces and features.
A UNIX-style OS~\cite{ritchie74unix}
encapsulates hardware distinction using a system interface as the system call table.
Without a system interface,
developers will have to program against hardware interfaces defined by manufacturers.
Programming against bare hardware
creates applications that are restricted to 
specific hardware.
Operating systems allow application developers to program against a consistent, hardware-independent
system interface, %with a consistent view of system features,
%A system interface must be independent from the idiosyncrasy of hardware,
so that the applications can be portable
across hardware configurations.







%, and allows applications to be widely deployed on different platforms.
%an OS can be a more powerful ``extended machine'',
%which is more feature-rich and homogeneous than the bare hardware~\cite{dhamdhere2007os-textbook}.
%The purpose of an extended machine
%is to provide a consistent view for all the system features,
%which are independent from the choice of hardware.
%available for programming.
%presented by the system interface
%is independent from the physical machines running the OS.
%for applications to be programmed with.
%compared with the physical machines for running the OS.
%The value of a portable application is to be deployed and reused
%upon different hardware options, such as CPU models, memories, and I/O devices, as long as the system interface encapsulates the hardware.
%encapsulated by the OS.
%different encapsulated hardware options, including CPU models, memories, and I/O devices. 
%upon a series of continuously-developed hardware,
%including CPUs, memories, and I/O devices.
%Application portability requires an OS to export a system interface
%independent from hardware configurations,
%such as different CPU models, memory of different capacity, and various I/O devices.
%The only exception is the portability across CPU architectures,
%Otherwise, application developers would expect an application, built without dependency to %specific hardware, to be reusable in an OS regardless of what hardware users choose.
%The same assumption on application portability has been shared among
%Linux~\cite{linux-standard-base}, \win{}~\cite{win-api}, or POSIX~\cite{ieee-posix}.






%to facilitate application programming.
%to make applications adaptable and widely distributable.
%facilitate the development of an portable application.
%share the merit of application portability.



In general, OS developers preserve old system interfaces
to maintain compatibility for exiting application binaries.
%An application developed upon a system interface is subject to a different property as compatibility.
%for a specific OS depends on a system interface
%to remain compatible.
Compatibility of an OS can be
defined as 
the ability to reproduce a system interface with the requirements of applications.
%Application programming models are often influenced by the definition of system interface.
%A system interface contains
%a set of OS functions that applications
%call to describe the order and condition of requesting OS services.
Many applications are deployed as native code,
with usage of system interfaces
scattered inside application binaries.
%and does not easily change unless modifying source code.
%The development of a fully-compiled application (not as a script or intermediate code)
%includes hard-coding the usage of a system interface
%in the binaries.
%\polish{Application developers make the decisions of embedding the requests and parameters of interacting with a system interface inside of an application.}
%A fully-compiled application is mostly hard-coded with the usage of a system interface
%The programming of a system interface requires
%hard-coding the intention and condition of requesting OS services
%in the application code.
To accommodate unmodified applications,
OS developers share a common goal to keep a system interface
compatible across OS versions.
%If a milestone of OS development involves modifying a part of the system interface,
%an application becomes obsolete
%if it contains outdated system interface specifications.
%due to mismatching with the latest definition.
Compatibility is also a goal for less widely-used OSes, such as FreeBSD,
to emulate a more popular system interface, such as the Linux system call table,
to reuse more well-adopted applications.
%Although compilers and libraries can reconstruct or recast some OS functions,
%a principle-level or assumption-level change in the system interface
%would still be difficult to recover.
%by translating either at compile time or through a thin library.
%The common practice in OS development is to preserve
%the whole system interface,
%as application developers previously observe when building an application.


%is generally known as compatibility.






%Compatibility is broken when an OS developer decides to extend the system interface,
%in order to adopt new hardware.
%If a system interface is extended for a new hardware,
%existing applications need to be reprogrammed accordingly, using the latest system interface.
%Extensions to a system interface are usually in the form of \syscall{ioctl} operations in a POSIX-style OS,
%or new system call options such as the \code{MAP\_HUGETLB} flags for \syscall{mmap}.
%Unless an OS can be transparently extended for a new hardware,
%%be completely transparent to applications,
%users will have to tolerate the limitation that utilization of the hardware in applications
%will lag behind deployment,
%because of the additional porting efforts.



Unfortunately, the recent trend of hardware development
has challenged the feasibility of maintaining the compatibility of a system interface.
%An OS needs to be be continuously extended to utilize new hardware.
Although most new hardware share the same interfaces and semantics
with their predecessors,
%and requires no changes to existing system interfaces.
more cutting-edge hardware tend to leak out of
the typical hardware abstractions
encapsulated by an OS.
%and thus demands extra attention for adoption.}
%The challenges emerge as more ground-breaking hardware technologies
%have been released in the industry.
\issuedone{1.2.b}{Specify \sgx{} as a motivating example}
One example is \sgx{} (software guard extensions)~\cite{intelsgx}
on recent Intel CPUs.
\sgx{} protects an application
with integrity and confidentiality, without trusting other system components 
such as OSes, hypervisors, and system software.
Although an \sgx{} application
may still utilize system interfaces for OS functionality
such as file systems and networking, the application does not assume
the OS to be reliable.
Therefore, \sgx{} raises several compatibility issues to
existing system interfaces,
including security challenges such as
validating untrusted system call results~\cite{checkoway13iago}.
%however, \sgx{} also raises several compatibility issues, including reverting the trusted nature of OS services.
%and restricting the sharing of isolated application memory~\cite{shinde17panoply}.
Other examples can be found among research hardware,
such as asymmetric multi-processing architectures
without inter-connected memory~\cite{gschwind2007,cascaval2002evaluation},
which challenges inter-process coordination.
%which complicates the implementation of state-sharing, multi-process abstractions. 
%Despite the benefits of \sgx{} on application protection,
%\sgx{} requires changing the applications to defend against malicious OS services,
%and to work around several compatibility issues of the restricted ISA of \sgx{} (more details discussed in Section~\ref{sec:intro:sgx}).
%Especially, the size and subtlety of the Linux or \win{} system interface
%makes it unsuitable for adopting applications to \sgx{}~\cite{checkoway13iago}, because \sgx{} has fundamentally changed the nature of OS services.
%Several recent publications mitigate part of the compatibility issue for deploying applications on \sgx{}~\cite{baumann14haven,osdi16scone,shinde17panoply}.
%This thesis
%uses \sgx{} as a strong motivating example (see Section~\ref{sec:intro:sgx}),
%because \sgx{} fundamentally reverses a critical OS assumption, and causes a combination of compatibility and security problems.
%\sgx{} shows that compatibility issues can be distraction to innovations.
As more disruptive hardware
may emerge in the future, %OS developers should
%gradually promote new system interfaces which encapsulate latest hardware semantics; simultaneously,
applications need an immediate solution to these urgent compatibility issues.


Empirically, compatibility has caused struggles in OS development,
especially when API changes are demanded.
%An system interface may contain outdated specifications of OS features and application programming interfaces (APIs);
%~\polish{however, OS developers generally avoid modifying the system interface,
%despite of missed opportunities to
%improving both OS and application sides.}
For instance, Linux and similar OSes
introduce system calls such as \syscall{openat} as a version of \syscall{open}
without TOCTOU (time-to-check-to-time-to-use)
vulnerabilities.
Unfortunately,
to fully replace the original \syscall{open}, developers needs to modify every applications, otherwise Linux can never deprecate
the unsafe version.
%would be a painful and lengthy process,
%wherein every applications have to be reprogrammed accordingly.
%until the process finally expires.
%Imaginably, a more large-scale modification of the system interface
%may be catastrophic.
At a larger scale, an early version of \win{} Vista introduces
%Moreover, if a system interface is changed on a large scale,
%the result may be catastrophic:
%a well-known example is an early version of \win{} Vista,
%codenamed ``Longhorn'',
a brand-new user interface API
and file system,
but ends up losing popularity due to compatibility-related complaints~\cite{spolsky04microsoft-api-war}.
Because users may prioritize compatibility over adoption of new technology,
early stable versions of an OS,
such as \win{} XP, may remain popular even after end-of-service (EOL)~\cite{os-market-share}.
%Maintaining system interface compatibility is generally a responsibility of OS developers;
%while extending an OS for expanding the portability of applications
%on new hardware.
%Despite the OS extensions for future hardware,
%the system interface has to stay compatible with existing applications.
%Especially, OS developers may face compatibility issues
%when the adopted hardware leaks out of the abstractions encapsulated by the current system interface.
%Many examples show that
%These are examples that compatibility restrictions
%hinder OS development.
%\keepthis{In general, OS developers treat compatibility as an important factor to the usability of a system,
%but also an unwelcome distraction in the early stage of innovation.}


There are practical reasons
to maintain compatibility for unmodified applications in a commercial OS.
The development of a commercial application
includes a long process of thoroughly testing and examining the code to ensure correctness and safety.
Modifying an application for a new system interface
can introduce new risks to stability
and extra cost to restart the debugging cycle.
Moreover, third parties may have no access to source code of proprietary software even if they are motivated to port the applications.
All these dilemmas call for a universal solution
to mitigating
compatibility issues on reusing
unmodified applications.





\issuedone{1.1.b}{Specify the problem as reducing the gap of interface idiosyncrasy}
Compatibility issues alienate users from
system interface alternatives that grant access
to new hardware or 
introduce security or performance benefits.
This thesis proposes a general approach to building a compatibility layer
for translation of a legacy system interface.
%to various alternative definitions, as a solution to supporting unmodified applications.
%OS developers are free to redesign
%system interfaces
%for adopting new hardware or addressing system challenges.
%can't or shouldn't avoid modifying a system interface,
%yet existing application tend to rely on former system interface definitions to remain functional.
A compatibility layer between an application and an OS
can bridge the gap between system interfaces.
%system interface definitions, including both the APIs and the nature of OS features.
Take \sgx{} for example;
compatibility challenges on \sgx{} include
secure dynamic loading,
redirecting system calls to host OSes, and security checks against untrusted system calls.
The approach
reduces the effort of porting a compatibility layer
to any host OSes and hardware,
by eliminating the cost of reimplementing
numerous complex system APIs on each host.%~\cite{linux-man-syscall}.
%developing such a compatibility layer,
%so that maintaining compatibility would not become a burden in OS development and innovation.
%OS developers should not have
%to reimplement every features of a system interface in a compatibility layer;
%A modern OS such as Linux
%can contain up to 
This thesis presents a solution to building a rich-feature compatibility layer,
without tremendous cost
of updating applications to adjust
for a new system interface.









%%A system interface can contain up to hundreds or thousands of \linuxapi or OS functions, with numerous corner cases and programming options~\cite{ieee-posix, linux-man-syscall}.
%
%%is influenced by the design of plenty of pre-existing hardware,
%%and thus is difficult to change for another disruptive hardware.
%%For example, a monolithic OS, such as Linux or \win{}, assumes a unified kernel, which mediates all operations from applications to request hardware resources and abstractions.
%Also, an OS prototype built from scratch
%can redefine a system interface which accommodates a new hardware, or optimizes for it~\cite{baumann09barrelfish,peter14arrakis,belay14ix}.
%%and may require compatibility against deployed applications.
%%often chooses to adopt the system interface of a popular OS standard, such as POSIX or Linux, to reuse applications already under deployment.
%%It is a practical move to implement system interfaces from a popular open OS such a Linux,
%%to demonstrate the benefits of using an OS prototype
%%on running certain native applications.
%%An OS can define a system interface with up to hundreds or thousands of functions~\cite{ieee-posix, linux-man-syscall}. %nearly impossible to fully implement from scratch.
%However, to be compatible with existing applications,
%building a translation or emulation layer for reproducing the former OS behavior and semantic, upon either an adapted system interface or an OS prototype, is still necessary.






%An alternative to a VM is
%%an alternative to a VM, OS developers can partition an OS, to virtualize only necessary components into a thin compatibility layer}---
%a {\bf \libos{}}
%~\cite{porter11drawbridge,engler95exokernel,libra,unikernels},
%a user-space OS library loaded
%inside an application's address space.
%%when adopting an innovative hardware or alternative system interface.}
%%implementation of compatibility in an OS, in case the OS developers intend to extend the OS for new hardware.
%%reducing the difficulty of retaining compatibility
%%is to reduce the complexity of system interface which has to be reproduced, to achieve compatibility against existing applications.
%%when extending the OS implementation.
%The purpose of a \libos{} is to
%reproduce the features and API of a system interface on top of a library,
%upon a generic host interface.
%%inside a user-space, reusable {\em library} that executes upon a virtualized host interface.
%%Unlike the virtual hardware interface,
%Defining a host interface is for the simplicity of porting.
%%of OS development upon each host OS and hardware.
%The definition process
%is equivalent to
%finding a ``pinch point'' inside an OS,
%to partition out the high-level, host-independent OS components.
%%A library OS can be reused to build a compatibility layer for unmodified applications upon any host,
%%as long as the host interface is implemented.
%A host interface must be relatively easy to develop,
%so that porting the \libos{}
%requires less effort than redeveloping
%a compatibility layer.


This thesis presents
{\bf \graphene{}},
a library OS for running unmodified applications on innovative hardware and alternative system interfaces.
A \libos{}
~\cite{porter11drawbridge,engler95exokernel,libra,unikernels}
is a library which emulates OS features and APIs
in an application process.
This thesis focuses on building a \libos{}
%reproduce the features and API of a system interface on top of a library,
using a simple host interface defined for portability.
%inside a user-space, reusable {\em library} that executes upon a virtualized host interface.
%Unlike the virtual hardware interface,
Defining such a host interface % is for the simplicity of porting.
%of OS development upon each host OS and hardware.
%The definition process
is equivalent to
finding a ``pinch point'' inside an OS;
%which can be easily ported
%to various system interfaces.
%to partition out the high-level, host-independent OS components.
%A library OS can be reused to build a compatibility layer for unmodified applications upon any host,
%as long as the host interface is implemented.
%A host interface must be relatively easy to develop,
%so that porting the \libos{}
%requires less effort than redeveloping
%a compatibility layer.
the host interface partitions
OS components above this boundary, such as system calls and namespaces, into the \libos{} to make the components reusable
across host OSes and hardware.
This approach simplifies the porting effort per host
as exporting the host interface using a PAL (platform adaption layer).

\graphene{} reproduces a rich of Linux system calls
for a wide range of commercial applications
in server or cloud environments.
\graphene{} primarily targets three types of applications.
The first is a server or cloud application, such as Apache or Memcached.
The second is a command-line program used in a UNIX environment, such as a shell program or a compiler.
The last is a language runtime, such as R, Python, or OpenJDK,
which heavily deploys
system interfaces for language features
such as dynamic loading and garbage collection. 
\graphene{} implements \graphenesyscallnum{} out of \linuxsyscallnum{} Linux system calls.


Graphene defines a host ABI (application binary interface)
which contains
only essential host abstractions
that are easy to port on different host OSes. 
This thesis demonstrates the simplicity
by experimenting the porting
on two sample hosts---a native Linux kernel and an \sgx{} enclave on an untrusted Linux host.
%The \graphene{} library OS
%is developed upon a narrowed host interface, defined as a host ABI (application binary interface),
%to be easily ported to various host options.
%The host ABI isolates the implementation of Linux features and API, from addressing the low-level restriction and idiosyncrasy.
%The strength of \graphene{} is to fine-tune the host ABI,
%to simplify the host development and drop the assumptions on host OSes and hardware.
%So far \graphene{}
%has been targeting several host options,
The choices of host targets
cover two extreme cases of compatibility support with opposite security models.
This thesis enumerates the development effort of translating
and securing the host ABI on each host,
as demonstration of simplicity.
Other ongoing ports of the host ABI
include alternative OS kernels such as \win{}, \osx{}, and FreeBSD, and research OSes such as L4 microkernels~\cite{l4family} and Barrelfish~\cite{baumann09barrelfish}.


Building a \libos{} is similar to virtualizing 
%Building a compatibility layer
%can benefit from virtualizing 
a part of an OS.%, or more specifically, the system call table implementation.
\issuedone{1.2.c}{Discuss library OS vs VM}
A virtualization solution reuses OS components upon
an intermediate interface
such as a virtual hardware interface.
A virtual machine (VM) usually carries an unmodified, full-fledged OS kernel
to reproduce the whole system stack that
implements a system interface. 
%A virtual machine conveniently reuses existing OS implementation
%for reproducing the system interface,
Although a VM provides full compatibility for existing applications,
it requires a virtualizeable architecture~\cite{popek74virtual}
or assistance from
hardware virtualization such as VT (virtualization technology)~\cite{VT}
to mitigate software virtualization overheads.
%to mitigate 
%%Virtualization
%A VM can provide full compatibility
%by reusing an existing OS implementation.
%as long as the architecture is virtualizable.


\issuedone{1.2.d}{Specify target applications of Graphene libOS}
Compared to the alternatives,
the \libos{} approach strikes a better balance % the trade-offs
between simplicity of porting
and sufficiency of compatible OS functionality. % to be compatible against applications.
A study of Linux system interface~\cite{tsai16apistudy}
show that system calls
are not equally important to applications.
%upon different host OSes and hardware.
Applications also
subject to different popularity among users, as shown in
installation statistics~\cite{ubuntu-popularity}.
A portion of Linux system calls are strictly for administrative purposes,
such as configuring Ethernet cards and rebooting the machines,
and are 
exclusively used by
system software such as \code{ifconfig} and \code{reboot}.
%while each host OS is likely to have its own version of system software.
%and each host OS is likely to contain similar tools.
As a result, a \libos{} can selectively implement
system calls
based on importance for applications
with porting value.








%This OS design targets on commercial Linux applications used in cloud environment, including server applications, command-line programs, and language runtimes.
%This thesis shows that the defined host ABI is sufficient to implement a rich of OS functionality for reusing the said applications.


%This thesis shows that a library OS can implement a substantial amount of OS features needed by the reused applications,
%and the host ABI can be easily ported to a new physical machine or an alternative OS.
%using a host interface defined with simplicity and minimal assumptions. This \libos{} design, alone with the host interface, is potentially stackable on various operating systems, to benefit both backward and forward compatibility.



%This thesis shows the embodiment of an OS design as the \graphene{} library OS.
%The  library OS can run a wide range of unmodified Linux applications,
%including server-type applications, command-line programs, and language runtimes, on a set of host OSes and hardware platforms.
\graphene{} inherits 
a part of the host ABI from \drawbridge{}~\cite{porter11drawbridge},
a \libos{} developed for %reusing 
%which has demonstrated compatibility benefit over
\win{} applications.
\drawbridge{} uses the \libos{} as a lightweight VM
to run \win{} desktop applications in a guest environment.
Using a \libos{}
also improves the density of packing the guests on a physical host
due to significantly lower memory footprint than a VM.
%%as a partitioned OS component also requires
%less memory resource than a full VM,
%and thus improve the density of packing guests in a physical machine.
Bascule~\cite{baumann13bascule} later adopts the design
to implement single-process system calls in Linux.
%, and inserting host-level extension layers.
Haven~\cite{baumann14haven} further ports \drawbridge{} to \sgx{}, to shield \win{} application from untrusted host OSes.
\graphene{} %extends the concept of previous work
presents solution to running unmodified applications
upon a variety of host OSes and hardware,
with a host interface defined for both simplicity of porting 
and sufficiency for developing a rich Linux-compatible \libos{}.



%\issue{1.3.a}{Compare Graphene vs Docker}
%Established upon the previous work, 
The contributions of this thesis over previous work
are as follows.
First, this thesis
defines a host ABI which is easy to port
on new host platform,
by enumerating the porting effort, including translating host system interfaces and enforcing security checks.
Second,
this thesis demonstrates the development
of a \libos{}
using the host ABI,
and presents emulation strategies
for complex Linux features such as multi-process abstractions,
with reasonable overheads and memory footprints.
Third,
this thesis presents a quantitative method of evaluating compatibility
to prioritize system interface emulation
in a \libos{} or a research prototype.
 

%\begin{compactenum}
%\item \graphene{} explores and justifies the feasibility of building a library OS for resolving compatibility issues on various OSes and hardware.
%%(1) Reasoning about the portability and completeness of functionality.
%% of the host ABI and library OS design for both
%\item \graphene{} faithfully implements a rich of native Linux system calls, including several challenging features which are specific to Linux or UNIX,
%such as multi-process abstractions.
%\item \graphene{} shows it possible to engineer a library OS
%with practical performance overhead,
%and memory footprint close to a Linux process.
%\item Comparable to a VM, \graphene{} can enforce strong security isolation
%between mutually-untrusted applications,
%with a narrowed attack surface to the host kernel (more in Section~\ref{sec:intro:security}).
%\end{compactenum}


%\papersection{Evaluating API compatibility}



%This thesis studies the compatibility requirement in Linux and POSIX
%from the perspectives of applications and users.
%The study begins with building a metric for compatibility,
%weighted by the API usage in applications,
%and application importance (or popularity).
%%for measuring and implementing compatibility. The design principle applies to either a commodity OS, a newly-built OS prototype, or the \graphene{} library OS.
%%This thesis shows that the compatibility against the existing applications, in an OS, can be measured and incrementally improved by scientific approach.
%%Using a metric that is weighted by the usage of system interfaces in a large sample of commonly used applications, as well as the popularity of the sampled applications,
%Using the metric,
%OS developers can quantitatively determine the priority in implementing a system interface,
%and evaluate the developed results.
%The study shows that most applications do not require
%half of the Linux system calls,
%which are either for administrative use (e.g., halting the machine), or unpopular among applications.

\papersection{Motivating examples}

\issuedone{1.1.b}{Adding motivating examples in the intro}
This section shows two examples in which developing a compatible system interface for existing applications is challenging, to motivate the approach of the \graphene{} \libos{}.


\papersubsection{Unmodified applications on \sgx{}}
\label{sec:intro:sgx}


%One of the motivating examples, for using \libos{} to improve application compatibility,
%is the support of unmodified Linux application
%on the platform of Intel (\sgx{})~\cite{intelsgx}.
\sgx{}~\cite{intelsgx}, or Software Guard Extensions, are a set of new instructions on Intel CPUs.
%provide the hardware support for trustworthy, isolated execution, as part of the sixth-generation Intel CPU extensions.
%Using \sgx{}, application developers 
The purpose of \sgx{}
is to protect application code from compromised OSes, hypervisors, and system software,
with both integrity and confidentiality protection.
The abstraction of \sgx{} is 
an {\bf enclave}, 
which isolates and protects an application
on an untrusted host
to harvest the CPU and memory resources.
%such as a public cloud machine for rent, or a client machine,
%with both confidentiality and integrity.
%without leaking CPU and memory states.
Application code and data inside an enclave are both signed and encrypted
inside the DRAM
when leaving the CPU package.
%and will be authenticated and decrypted
%when bringing into the last-level cache at cache miss.
%By running the application code on \sgx{}, the code has 
%emory state inside of the protected code
%to be signed and encrypted, when the code and data leave the CPU package and are stored in the DRAM or swap device.
\sgx{} also offers remote attestation of the integrity of an enclave
and the CPU.
\sgx{} provides opportunities of delegating security-sensitive operations
to a untrusted public cloud
or client machine.
%without compromising on security.



%A Linux application running on Intel \sgx{} can receive end-to-end protection from the untrusted OSes, but also no longer have a trustworthy OS to faithfully return correct, benign OS features, such as reading a file or creating a thread.
%The untrusted OS can potentially launch attacks through manipulating  
%valid return values to applications, which are known as the Iago attacks.
%The problem of defending against Iago attacks is that these attacks are hard to predict among all the scenarios and corner cases in the full OS functionality of a modern OS like Linux or \win{}, given the complexity of OS semantics and the lack of study on untrusted OSes.
%As a result,
%building an ad hoc compatibility layer to implement and defend OS features for general Linux applications in Intel \sgx{}
%not only is cumbersome but also cannot be properly checked for security.


Despite the benefits,
the common expectation for \sgx{} is
that developers need to port a piece of application code to run inside an enclave.
The restriction is for both security and simplicity,
since each enclave
needs a static code image with 
security measurement
signed by users.
%and thus is easier to sign and verify.
Developers also have to remove system calls and
certain instructions such as \code{cpuid} and \code{rdtsc}
as they compromise
security without further enforcements.
%If users intend to run an unmodified application, \sgx{} imposes several restrictions on running unmodified applications inside an enclave.
%The restrictions are either imposed by the \sgx{} hardware in the run time, or statically by the official Intel \sgx{} SDK (software development kit).
%\sgx{} forbids these instructions
%for blocking
%dangerous behaviors that may jeopardize application security.
For instance,
system calls serviced by an untrusted OS
may returns malicious results to exploit semantic flaws in an application caused by being unaware of the attack vectors.
\sgx{} forbids \code{cpuid} and \code{rdtsc} because these instructions are easily intercepted or spoofed by an OS
or a hypervisor.
These restrictions introduce porting efforts to existing applications on \sgx{}.

%%including \code{cpuid} and \code{rdtsc}, for the clarity of shielding these hardware features.
%\sgx{} forbids \code{cpuid} in case of combining with the hardware virtualization (VT),
%to avoid trapping to hypervisors.
%%, which is untrusted in the threat model of \sgx{}.
%\sgx{} also forbids \code{rdtsc}, in order to rule out potential physical attacks on the Time Stamp Counter (TSC). 
%%The application developers would have to remove these instructions from the applications in order to run inside an enclave.


\issuedone{1.2.c}{Discuss challenges of \sgx{} shielding}
The threat model of \sgx{} distrusts OS services, except APIs that can be fully migrated into an enclave (e.g., \syscall{malloc} and \syscall{memcpy}).
The absence of trusted OS services is an issue for porting any application to \sgx{}.
Existing solutions combine a modified C library with applications, to redirect system calls
to the untrusted OS~\cite{osdi16scone,shinde17panoply}.
The problem, however, is in checking the results of system interfaces, because the OS is not trusted. % to faithfully implement OS services.
%Checks against simple attacks are possible,
%such as checking if returned pointers are valid to the enclave regions.
%to \syscall{mmap} which points to existing memory regions that can be corrupted or can leak sensitive information
Previous work~\cite{checkoway13iago} shows that
checking untrusted system interface results can be subtle, because the existing system interfaces are not designed for an untrusted or compromised OS.


In summary, the existing porting models of \sgx{} requires modifying application binaries, and injecting security checks for all the OS features used by an application.
%checking reasoning about the completeness of checking system interfaces.
This thesis argues that, by introducing a library OS into enclaves,
the interaction with the untrusted OS can be restricted to OS services which have clear semantics for checking.
%an narrowed, fixed enclave interface can be defined, to restrict interaction with the untrusted OS to services that can be explicitly checked.
By implementing the host ABI inside an enclave,
users can easily run an unmodified Linux application, such as an Apache server or a Python runtime, upon a trusted \libos{}.



\papersubsection{Emulating multi-process abstractions}
\label{sec:intro:multiproc}


\issuedone{1.3.b}{Using multi-process as a motivating example}
One characteristic of a UNIX program
is the utilization of multi-process abstractions,
such as \syscall{fork}, \syscall{exec},
and inter-process communication,
to program self-contained sessions or commands.
In particular, \syscall{fork} is an unique feature of UNIX-style OSes, such as Linux and BSD,
which clones a process with address space isolation
between the parent and child.
%mostly with copy-on-write paging.
%The process state can be easily tore down at exit.
Multi-process abstractions are convenient for creating a temporary session for processing incoming requests or commands, and destroying the session without corrupting the parent process.



\begin{figure*}
\begin{minipage}[t]{.65\textwidth}
(Parent process: \code{"sh"})
\lstset{basicstyle=\ttfamily\footnotesize,fontadjust=true,breaklines=true}
\begin{lstlisting}
char pid[10], *argv[]={"kill",pid,0};
itoa(getpid(), pid, 10);
if (!fork()) //clone a process
  execv("/bin/kill", argv);
wait(NULL);  //wait for signal
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{.33\textwidth}
(Child process: \code{"kill"})
\lstset{basicstyle=\ttfamily\footnotesize,fontadjust=true,breaklines=true}
\begin{lstlisting}

pid=atoi(argv[1]);
//send a signal
kill(pid, SIGKILL);

\end{lstlisting}
\end{minipage}
\caption{Sample code for Linux applications using process cloning and inter-process communication (IPC).}
\label{fig:overview:proc-example}
\end{figure*}

For programmability, Linux and similar OSes export several inter-process communication (IPC) mechanisms,
each with unique use cases and semantics.
The Linux IPC essentially combines the UNIX System V features, such as message queues and semaphores,
and POSIX abstractions, such as signaling and namespaces,
to present a wide range of options for programming.
%The implementation of these mechanisms is idiosyncratic to Linux applications, and has to coordinate several global states across all processes.
Figure~\ref{fig:overview:proc-example} shows a code example of
two Linux programs (``\code{sh}'' and ``\code{kill}'')
running in parallel as part of a multi-process application and communicating with signals.
%Signaling between the parent and child processes
%can happen in several occasions, including processes being terminated accidentally or deliberately, and one process calling the \syscall{kill} system call.
The destination of signaling is determined by a unique process identifier (PID)
known by all processes.
These kinds of identifiers or names are globally shared, as part of the POSIX namespaces,
among applications or processes visible to each other.




Monolithic OSes such as Linux generally implements IPC mechanisms as shared states in a coherent kernel space.
%Implementing IPC mechanisms in an OS used to rely on a coherent kernel space, but can be challenging when an OS makes the opposite assumption.
%Since coordination is necessary for multi-process applications, 
%The easiest design is to store the states and namespace in the kernel memory accessible to all processes.
Sharing kernel states, however, causes process sandboxing
to be vulnerable in the kernel space.
%or in an application
%isolated by hardware like Intel \sgx{}.
An isolated OS design tends to avoid sharing privileged OS states with other applications.
%For example, on \sgx{}, an enclave cannot share trusted memory with other enclaves.
%The only possible solution without introducing more OS functionality into enclaves is to export the encrypted states to the untrusted kernel, which will suffer significant overheads.


Moreover, not all architectures share the same assumption of having an inter-connected, coherent memory.
Several recent architectures lack memory coherence
in exchange of simplicity of implementation~\cite{gschwind2007,cascaval2002evaluation}.
Barrelfish~\cite{baumann09barrelfish} demonstrates an efficient OS design, called multikernels, which runs distributed OS nodes on CPUs with inter-node coordination by message passing.
The distributed OS design resonates with the \graphene{} library OS, which uses RPC (remote procedure call) streams to implement multi-process abstractions.
%\graphene{} can be a flexible option for building up compatibility against multi-process applications.
Since \graphene{} does not assume a coherent kernel space, it can be a flexible option
for porting multi-process applications to a variety of OSes and architectures.



\papersection{Security isolation}
\label{sec:intro:security}

\issuedone{1.1.d}{Separate the motivation for security isolation}



%In traditional systems, the security of an application is built upon
%trusting the whole system stack to enforce its security policies.
%The system stack needed to be trusted
%--- as part of the application's {\em trusted computing base (TCB)}
%--- includes the hardware (from CPUs to devices), operating systems, system libraries, and language runtimes (a languge runtime can be considered an application or part of the system stack).
%If a vulnerability exists anywhere in the system stack,
%attackers can exploit the vulnerability to bypass the security mechanisms the application rely on,
%compromising any security policies that application enforces.


As a bonus benefit, \graphene{} also
reduces the complexity of enforcing security isolation on applications,
under different threat models.
For instance, on a Linux host, the security implication of using \graphene{} is to isolate mutually-untrusting applications,
similar to running each of these applications inside a OS sandbox.
A \sgx{} host, on the other hand, enforces a different threat model,
where an enclave untrusted any OS components and applications running
outside of the enclave.
With two opposite threat models,
\graphene{} shows how to simplify security isolation
by separating API implementation from enforcing security policies.



%trusting the whole system stack to enforce its security policies.
%The system stack needed to be trusted
%--- as part of the application's {\em trusted computing base (TCB)}
%--- includes the hardware (from CPUs to devices), operating systems, system libraries, and language runtimes (a languge runtime can be considered an application or part of the system stack).
%If a vulnerability exists anywhere in the system stack,
%attackers can exploit the vulnerability to bypass the security mechanisms the application rely on,
%compromising any security policies that application enforces.


%The existence of vulnerabilities in the trusted system stack especially affects applications that run in a multi-tenant environment, such as {\em cloud} environment.
%If there is only one tenant,
%the application or user will behaves benignly,
%without actively attempting to discover or exploit any system vulnerabilities.
%On the contrary, in a multi-tenant environment,
%the application or user can share the same host with a malicious application or user,
%who will act to compromise the system stack.
%The problem can never be completely resolved by security checks,
%because vulnerabilities can exist in the security logics,
%and the attackers who succeed exploiting the vulnerabilities may bypass the checks.

%To address the problem of system vulnerabilities, system researchers have engaged efforts in building more secure operating systems,
%to isolate the consequence of compromised system stacks.
%For instance,
%micro-kernels, such as Exokernel~\cite{engler95exokernel} or HiStar~\cite{zeldovich+histar},
%intend to reduce the TCB in the operating systems that are shared by applications.
%The operating system components that are removed from the shared TCB are placed into a {\em library OS}, which operates in the userspace or even in the application processes.
%If a malicious application attack its library OS,
%the succeeded exploitation will only affect the very piece of library OS,
%whereas other applications are isolated.
%Because the complexity of the host kernel is significantly reduced,
%it is easier to eliminate its vulnerabilities.

%Another common approach of enforcing security isolation against malicious application to use virtualization.
%With virtualization, the shared TCB among all the guests (or tenants)
%are reduced to a minimal hypervisor,
%and each guest will be running in an isolated virtual machine which loads a monolithic guest operating systems.
%Similar as the applications isolated by library OSes, the exploitation that occurs in each guest OS will not affect other guests.

%Either library OSes or virtual machines does not defend against two types of attacks.
%The first type of attack is from the malicious host providers.
%In cloud environment, a malicious provider can load a modified kernels or hypervisors into the hosts,
%bypassing the security isolation enforced by library OSes or virtual machines.
%Even without loading a malicious system stack,
%the provider can still attack the hosts by physically launching attacks on the hardware, using techniques such as the Cold-boot Attack~\cite{halderman09coldboot} or 
%intrude the boot process using counterfeit peripheral devices.
%Finally, library OSes or virtual machines does not defend against vulnerabilities
%inside an application or a process
%that can be exploited to attack the application itself.
%For instance, the Heartbleed bug~\cite{heartbleed} discovered in OpenSSL cryptography library
%can leak the private keys of trusted authorities through the vulnerability in OpenSSL's heartbeating service.
%To eliminate vulnerabilities in a complex, modern applications is as infeasible as eliminating vulnerabilities in the operating systems.




Similar as the complexity of emulation,
%the whole system table on a host,
security isolation inside a monolithic OS is delicate and prone to vulnerabilities.
%if each abstraction is controlled individually.
The host ABI of \graphene{} simplifies
the isolation of OS abstractions
down to three host abstractions that are sharable among \picoprocs{}: files, network connections, and RPC streams.
For each of these sharable host abstraction, \graphene{} enforces isolation policies using semantics
commonly known and used by security experts;
for instance, to specific file access rules, users provide a list of permitted files, similar to a profile for the AppArmor kernel module.
For network connections,
users specify firewall-like network rules,
to permit an application
to bind to a local network address, or to connect to a remote network address.
Finally, for RPC streams,
\graphene{} simply blocks any RPC streams
which cross sandbox boundary.
This thesis show that,
by enforcing isolation rules on three host abstractions,
\thehostabi{} isolates the whole system call table inside each \picoproc{}.



For \sgx{}, \graphene{} addresses a specific set of security isolation challenges.
In addition to isolating mutually-untrusting applications,
\graphene{} also isolate an \sgx{} application
from untrusted operating systems, hypervisor, or system software.
Existing system APIs, such as system calls, expose a wide attack surface
to an untrusted host, where an adversary
can manipulate system API results to explore attack vectors~\cite{checkoway13iago}.
\graphene{} simplifies
the protection against random system API results which may or may not be malicious,
by redefining a fixed-width enclave interface
with security checks in mind.
This thesis also enumerates the security checks for each enclave call,
to verify the completeness
of protection against untrusted host components.









\papersection{Summary}

This thesis contributes a library OS design, called \graphene{},
which demonstrates the benefits on reusing unmodified Linux applications, upon new hardware or OS prototypes.
Compared with ad-hoc translation layers,
a library OS with a rich of Linux functionality (\graphenesyscallnum{} system calls) can be reused on various host platforms, as an adaptable layer with compatibility.
\graphene{} can adapt to the restrictions and
limited hardware abstractions on a host, with acceptable performance and memory footprint.
This thesis further reasons about the sufficiency of a library OS
for running frequently-reused applications. The reasoning is based on a metric which can evaluate the partial compatibility of a system interface.
\graphene{} prioritizes indispensable system calls over administrative or unpopular features,
to reuse a wide range of applications, from server applications to language runtimes.


\paragraph{Previous publications.}
The initial design of the \graphene{} library OS is presented in \cite{tsai14graphene}, which emphasizes on security isolation, between mutually-untrusted applications.
A later publication~\cite{tsai17graphene-sgx} focuses on porting the host ABI
to Intel \sgx{} and demonstrates security benefits 
over using a thin API redirection layer. % and usability features to run unmodified applications.
\cite{tsai16apistudy} presents the compatibility metrics for compatibility,
with a study of the Linux API usage among Ubuntu users and applications.

\papersection{Organization}

The rest of this thesis is organized as follows:
Chapter~\ref{chap:overview} describes the overview of Graphene (including the host ABI and the library OS) and the design principles behind the implementation.
Chapter~\ref{chap:abi} formally defines the host ABI, and provides a specification of the host-specific PAL (platform adaption layer).
Chapter~\ref{chap:libos} discusses the library OS in details.
Chapter~\ref{chap:linux} describes the PAL on Linux, as an example of implementing the host ABI and security isolation between library OS instances.
Chapter~\ref{chap:sgx} discusses \sgx{}-specific challenges to application porting, and the PAL implementation inside a \sgx{} enclave.
Chapter~\ref{chap:eval} evaluates the performance and memory footprint of \graphene{} and \graphenesgx{},
and presents a security study.
Chapter~\ref{chap:metric} presents a quantitative metric for compatibility,
to evaluate the completeness of Linux functionality in \graphene{}.
%Chapter~\ref{chap:study} presets a study of the Linux API importance, to give an insight about prioritizing API implementation.
%uses the metrics of API importance, to study the usage of Linux interfaces in applications.
Chapter~\ref{chap:related} discusses the related work.
Chapter~\ref{chap:conclusion} concludes the thesis.
