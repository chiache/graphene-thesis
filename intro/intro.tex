\chapter{Introduction}
\label{chap:intro}

\keepthis{Operating systems simplify the programming of an application, to utilize a wide range of hardware.}
\keepthis{A UNIX-style OS~\cite{ritchie74unix}
encapsulates hardware resources and abstractions, using a system interface.}
Without a system interface,
an application will have to be programmed against
hardware interfaces defined by manufacturers.
The problem of programming against bare hardware
is that the execution of applications is bound to specific hardware options.
\keepthis{Operating systems allow application developers to program against
a consistent, hardware-independent
system interface, %given a consistent view of the system features.
%A system interface must be independent from the idiosyncrasy of hardware,
so that application developers can avoid making assumption
or restricting users to run an application on specific hardware.}






%, and allows applications to be widely deployed on different platforms.
%an OS can be a more powerful ``extended machine'',
%which is more feature-rich and homogeneous than the bare hardware~\cite{dhamdhere2007os-textbook}.
%The purpose of an extended machine
%is to provide a consistent view for all the system features,
%which are independent from the choice of hardware.
%available for programming.
%presented by the system interface
%is independent from the physical machines running the OS.
%for applications to be programmed with.
%compared with the physical machines for running the OS.
%The value of a portable application is to be deployed and reused
%upon different hardware options, such as CPU models, memories, and I/O devices, as long as the system interface encapsulates the hardware.
%encapsulated by the OS.
%different encapsulated hardware options, including CPU models, memories, and I/O devices. 
%upon a series of continuously-developed hardware,
%including CPUs, memories, and I/O devices.
%Application portability requires an OS to export a system interface
%independent from hardware configurations,
%such as different CPU models, memory of different capacity, and various I/O devices.
%The only exception is the portability across CPU architectures,
%Otherwise, application developers would expect an application, built without dependency to %specific hardware, to be reusable in an OS regardless of what hardware users choose.
%The same assumption on application portability has been shared among
%Linux~\cite{linux-standard-base}, Windows~\cite{win-api}, or POSIX~\cite{ieee-posix}.






%to facilitate application programming.
%to make applications adaptable and widely distributable.
%facilitate the development of an portable application.
%share the merit of application portability.




\keepthis{An application developed in an OS is dependent on the system interface
to remain compatible with previous OS generations.}
\keepthis{This thesis defines {\bf compatibility} as
the ability of reproducing a system interface that satisfies the hard-coded requirement of applications.}
%Application programming models are often influenced by the definition of system interface.
%A system interface contains
%a set of OS functions that applications
%call to describe the order and condition of requesting OS services.
The development of a fully-compiled application (not as a script or intermediate code)
includes hard-coding the usage of a system interface
in the binaries.
\polish{Application developers make decisions of embedding the requests and parameters of interacting with a system interface inside of an application.}
%A fully-compiled application is mostly hard-coded with the usage of a system interface
%The programming of a system interface requires
%hard-coding the intention and condition of requesting OS services
%in the application code.
If a milestone of OS development involves modifying a part of the system interface,
an application becomes obsolete
if it contains outdated system interface specifications.
%due to mismatching with the latest definition.
Although compilers and libraries can reconstruct or recast some OS functions,
a principle-level or assumption-level change in the system interface
would still be difficult to recover.
%by translating either at compile time or through a thin library.
The common practice in OS development is to preserve
the whole system interface,
as application developers previously observe when building an application.

%is generally known as compatibility.



\keepthis{OS developers often struggle to maintain compatibility while improving
the relationship between the OS and applications.}
An system interface may contain outdated specifications of OS features and application programming interfaces (APIs);
~\polish{however, OS developers generally avoid modifying the system interface,
despite of missed opportunities to
improving both OS and application sides.}
For example, Linux and similar OSes
introduce \linuxapis{} such as \syscall{openat} as an unracy version
of \syscall{open}.
%to prevent TOCTOU (time-to-check-to-time-to-use) attacks.
Unfortunately, complete deprecation of the unsafe \syscall{open} system call
would be a painful and lengthy process,
wherein every applications have to be reprogrammed accordingly.
%until the process finally expires.
%Imaginably, a more large-scale modification of the system interface
%may be catastrophic.
Moreover, if a system interface is changed on a large scale,
the result may be catastrophic:
a well-known example is the cancellation of an early version of Windows Vista, 
codenamed ``Longhorn'',
which introduced a brand-new user interface API
and a database-like file system, but sacrificed compatibility~\cite{spolsky04microsoft-api-war}.
%Maintaining system interface compatibility is generally a responsibility of OS developers;
%while extending an OS for expanding the portability of applications
%on new hardware.
%Despite the OS extensions for future hardware,
%the system interface has to stay compatible with existing applications.
%Especially, OS developers may face compatibility issues
%when the adopted hardware leaks out of the abstractions encapsulated by the current system interface.
%Many examples show that
%These are examples that compatibility restrictions
%hinder OS development.
\keepthis{In general, OS developers treat compatibility as an important factor to the usability of a system,
but also an unwelcome distraction in the early stage of innovation.}



%Compatibility is broken when an OS developer decides to extend the system interface,
%in order to adopt new hardware.
%If a system interface is extended for a new hardware,
%existing applications need to be reprogrammed accordingly, using the latest system interface.
%Extensions to a system interface are usually in the form of \syscall{ioctl} operations in a POSIX-style OS,
%or new system call options such as the \code{MAP\_HUGETLB} flags for \syscall{mmap}.
%Unless an OS can be transparently extended for a new hardware,
%%be completely transparent to applications,
%users will have to tolerate the limitation that utilization of the hardware in applications
%will lag behind deployment,
%because of the additional porting efforts.




\keepthis{Sometimes, the adoption of an innovative hardware
poses unexpected challenges to maintaining compatibility in OS development.}
%An OS needs to be be continuously extended to utilize new hardware.
\polish{A new hardware that follows a similar design as its predecessors
can be adopted by the OS using a standardized driver.
However, a cutting-edge or research hardware may not fall into
the typical abstractions
encapsulated by the driver interfaces,
and thus demands extra attention for adoption.}
The challenges emerge as more ground-breaking hardware technologies
have been released in the industry.
\issuedone{1.2.b}{Specify SGX as a motivating example}
For example, CPU technologies like Intel SGX (software guard extensions)~\cite{intelsgx}
change the relationship between the OS and applications.
SGX supports developing
an application with self-protection against malicious OSes, hypervisors, and administrators;
however, SGX also raises several compatibility issues, including reverting the trusted nature of OS services.
%and restricting the sharing of isolated application memory~\cite{shinde17panoply}.
Other examples can be found among research-type architectures,
such as an asymmetric multi-processing architectures
without inter-connected memory~\cite{gschwind2007,cascaval2002evaluation}.
%which complicates the implementation of state-sharing, multi-process abstractions. 
%Despite the benefits of SGX on application protection,
%SGX requires changing the applications to defend against malicious OS services,
%and to work around several compatibility issues of the restricted ISA of SGX (more details discussed in Section~\ref{sec:intro:sgx}).
%Especially, the size and subtlety of the Linux or Windows system interface
%makes it unsuitable for adopting applications to SGX~\cite{checkoway13iago}, because SGX has fundamentally changed the nature of OS services.
%Several recent publications mitigate part of the compatibility issue for deploying applications on SGX~\cite{baumann14haven,osdi16scone,shinde17panoply}.
%This thesis
%uses SGX as a strong motivating example (see Section~\ref{sec:intro:sgx}),
%because SGX fundamentally reverses a critical OS assumption, and causes a combination of compatibility and security problems.
%SGX shows that compatibility issues can be distraction to innovations.
\polish{In the long term, OS developers should consider
gradually promoting a new system interface that can encauplate the latest hardware, but existing applications still need a timely solution to resolve the urgent compatibility issues.}




\polish{A practical reason for maintaining compatibility
is the fact that
application developers may be unwilling to modify an application,
at the stage of either source code or compiled binaries.}
The development of a commercial application
requires a thorough process of testing and code inspection to ensure the correctness and safety of execution.
Application developers may consider modifying or recompiling an application %for a new hardware or system interface to be 
a risk to application stability.
Even if users are willing to modify applications on their own,
application developers may be reluctant to release the proprietary source code.
These dilemmas call for a solution
to translate an alternative system interface for unmodified applications.





\issuedone{1.1.b}{Specify the problem as reducing the gap of interface idiosyncrasy}
To formalize the problem,
OS developers can't or shouldn't avoid modifying a system interface,
yet existing application tend to rely on former system interface definitions to remain functional.
A reasonable approach is to insert a compatibility layer
between the application and the OS,
to bridge the gap of system interface definitions, including both the APIs and the nature of OS features.
Take SGX for example:
\polish{a compatibility layer for supporting unmodified applications on SGX
must redirect the requests for system API to the host OS,
as well as validate the results of OS services in case the host OS is malicious.}
Another goal is to reduce the effort of developing such a compatibility layer,
so that maintaining compatibility would not become a burden in OS development and innovation.
OS developers should not have
to reimplement every features of a system interface in a compatibility layer;
A modern OS such as Linux
can contain up to hundreds or thousands of functions,
with lots of options and corner cases to implement~\cite{linux-man-syscall}.
\polish{Ultimately, this thesis is presenting a solution
for building a compatibility layer that reproduces a rich-feature system interface,
with less development effort.}








%%A system interface can contain up to hundreds or thousands of \linuxapi or OS functions, with numerous corner cases and programming options~\cite{ieee-posix, linux-man-syscall}.
%
%%is influenced by the design of plenty of pre-existing hardware,
%%and thus is difficult to change for another disruptive hardware.
%%For example, a monolithic OS, such as Linux or Windows, assumes a unified kernel, which mediates all operations from applications to request hardware resources and abstractions.
%Also, an OS prototype built from scratch
%can redefine a system interface which accommodates a new hardware, or optimizes for it~\cite{baumann09barrelfish,peter14arrakis,belay14ix}.
%%and may require compatibility against deployed applications.
%%often chooses to adopt the system interface of a popular OS standard, such as POSIX or Linux, to reuse applications already under deployment.
%%It is a practical move to implement system interfaces from a popular open OS such a Linux,
%%to demonstrate the benefits of using an OS prototype
%%on running certain native applications.
%%An OS can define a system interface with up to hundreds or thousands of functions~\cite{ieee-posix, linux-man-syscall}. %nearly impossible to fully implement from scratch.
%However, to be compatible with existing applications,
%building a translation or emulation layer for reproducing the former OS behavior and semantic, upon either an adapted system interface or an OS prototype, is still necessary.



The development of a compatibility layer
can benefit from virtualizing the upper layers of an OS, or even the whole OS.
An OS always contains
several components that are independent from
encapsulating hardware or upholding OS assumptions (e.g., multiprocessing).
For example, a major task of the API components
(e.g., system call table)
is to interpret the user inputs,
as well as to update or retrieve the related OS states.
Virtualization can preserve these OS components,
using an intermediate interface
exported by the host OS.
\issuedone{1.2.c}{discuss library OS vs VM}
Virtualization allows a VM (virtual machine) to carry an unmodified OS kernel,
as a full-stack compatibility layer
for applications.
A VM relies on a virtual hardware interface as the intermediate
to the host;
%A virtual machine conveniently reuses existing OS implementation
%for reproducing the system interface,
the virtual hardware interface requires a CPU architecture with virtualization support~\cite{popek74virtual}
such as Intel VT (virtualization technology)~\cite{VT}.
Virtualization can provide full compatibility
by reusing an OS implementation,
as long as the architecture is virtualizable.





\polish{As an alternative to a VM, OS developers can partition an OS, to virtualize only necessary components into a thin compatibility layer}---a {\bf \libos{}}~\cite{porter11drawbridge,engler95exokernel,libra,unikernels}
to load inside applications.
%when adopting an innovative hardware or alternative system interface.}
%implementation of compatibility in an OS, in case the OS developers intend to extend the OS for new hardware.
%reducing the difficulty of retaining compatibility
%is to reduce the complexity of system interface which has to be reproduced, to achieve compatibility against existing applications.
%when extending the OS implementation.
The purpose of a \libos{} is to
reproduce the features and API of a system interface,
inside a user-space, reusable {\em library} that executes upon a virtualized host interface.
Unlike the virtual hardware interface,
a virtualized host interface to the library OS is redefined for the simplicity
of OS development upon each host OS and hardware.
\polish{The host interface is
derived from a ``pinch point'' found inside an OS,
to partition the high-level, hardware-independent OS components,
into a \libos{}.}
A library OS can be reused to build a compatibility layer for unmodified applications upon any host,
as long as the host interface is implemented.


This thesis presents
{\bf \graphene{}},
a library OS for running unmodified applications upon innovative hardware and alternative system interfaces.
\graphene{} chooses the rich-feature Linux system interface (i.e., \linuxapis{})
as the target for reproducing.
\polish{The goal of \graphene{}
is to build a compatibility layer for reusing a wide range of Linux commercial applications,
to benefit the highly-customizable server and cloud environments.}
The \graphene{} library OS
is developed upon a narrowed host interface, defined as a host ABI (application binary interface),
to be easily ported to various host options.
The host ABI isolates the implementation of Linux features and API, from addressing the low-level restriction and idiosyncrasy.
The strength of \graphene{} is to fine-tune the host ABI,
to simplify the host development and drop the assumptions on host OSes and hardware.
So far \graphene{}
has been targeting several host options,
including innovative CPU platforms (e.g., SGX), alternative kernels (e.g., Windows, OSX, and FreeBSD), and research-type OSes (e.g., L4 microkernels~\cite{l4family}, Barrelfish~\cite{baumann09barrelfish}).



\issuedone{1.2.d}{Specify target applications}
\graphene{} balances the trade-offs
between compatibility against applications and adaptability against hosts.
According to
a study of Linux system API~\cite{tsai16apistudy},
\linuxapi{} are not equally important to applications.
%upon different host OSes and hardware.
Also, not every applications deserve to be reused upon different host OSes and hardware~\cite{ubuntu-popularity}.
The study shows that
a portion of the Linux \linuxapis{} are defined for administration purposes,
such as configuring ethernet cards and rebooting.
These \linuxapis{} are exclusively used by administrative programs,
such as \code{ifconfig} and \code{reboot},
and each host OS is likely to contain similar programs.
%and each host OS is likely to contain similar tools.
\graphene{} is primarily targeting three types of applications:
server and cloud applications (e.g., Apache, Memcached), command-line programs (e.g., Bash, GCC), and language runtimes (e.g., Python, OpenJDK).
The \graphene{} library OS is sufficient for running these applications,
by implementing a portion of the Linux \linuxapis{} (\graphenesyscallnum{} out of \linuxsyscallnum{}),
upon a narrowed host ABI containing \palcallnum{} functions.




%This OS design targets on commercial Linux applications used in cloud environment, including server applications, command-line programs, and language runtimes.
%This thesis shows that the defined host ABI is sufficient to implement a rich of OS functionality for reusing the said applications.


%This thesis shows that a library OS can implement a substantial amount of OS features needed by the reused applications,
%and the host ABI can be easily ported to a new physical machine or an alternative OS.
%using a host interface defined with simplicity and minimal assumptions. This \libos{} design, alone with the host interface, is potentially stackable on various operating systems, to benefit both backward and forward compatibility.



%This thesis shows the embodiment of an OS design as the \graphene{} library OS.
%The  library OS can run a wide range of unmodified Linux applications,
%including server-type applications, command-line programs, and language runtimes, on a set of host OSes and hardware platforms.
\graphene{} inherits 
a foundation of the host ABI from \drawbridge{}~\cite{porter11drawbridge},
a previous library OS developed for reusing 
%which has demonstrated compatibility benefit over
Windows applications.
\polish{The purpose of \drawbridge{} is to use the \libos{} as a lightweight VM,
to run applications in a guest environment.}
Because the library OS is built by partitioning OS components,
it requires far less memory resource than running a VM with a full, unmodified OS kernel.
The \drawbridge{} design is later adopted by Bascule~\cite{baumann13bascule}
to show the feasibility of implementing single-process, Linux functionality, and inserting host-level extension layers.
Haven~\cite{baumann14haven} later ports \drawbridge{} to SGX,
to protect unmodified Windows application isolated by SGX, against malicious inputs from the OS services.
\polish{\graphene{} extends the concept of previous work,
to present an overall solution over a variety of host OSes and hardware,
and to reason about the definition of an ideal host interface.}


%\issue{1.3.a}{Compare Graphene vs Docker}
%Established upon the previous work, 
The contributions of this thesis over previous work are as follows:
\begin{compactenum}
\item \graphene{} explores and justifies the feasibility of building a library OS for resolving compatibility issues on various OSes and hardware.
%(1) Reasoning about the portability and completeness of functionality.
% of the host ABI and library OS design for both
\item \graphene{} faithfully implements a rich of native Linux system calls, including several challenging features which are specific to Linux or UNIX,
such as multi-process abstractions.
\item \graphene{} shows it possible to engineer a library OS
with practical performance overhead,
and memory footprint close to a Linux process.
\item Comparable to a VM, \graphene{} can enforce strong security isolation
between mutually-untrusted applications,
with a narrowed attack surface to the host kernel (more in Section~\ref{sec:intro:security}).
\end{compactenum}


\paragraph{Compatibility evaluation and study.}
This thesis studies the compatibility requirement in Linux and POSIX
from the perspectives of applications and users.
The study begins with building a metric for compatibility,
weighted by the API usage in applications,
and application importance (or popularity).
%for measuring and implementing compatibility. The design principle applies to either a commodity OS, a newly-built OS prototype, or the \graphene{} library OS.
%This thesis shows that the compatibility against the existing applications, in an OS, can be measured and incrementally improved by scientific approach.
%Using a metric that is weighted by the usage of system interfaces in a large sample of commonly used applications, as well as the popularity of the sampled applications,
Using the metric,
OS developers can quantitatively determine the priority in implementing a system interface,
and evaluate the developed results.
The study shows that most applications do not require
half of the Linux system calls,
which are either for administrative use (e.g., halting the machine), or unpopular among applications.



\section{Motivating Examples}

\issuedone{1.1.b}{motivating examples}
This section shows two examples in which developing a compatible OS for existing applications can be challenging, to motivate the library OS design.


\subsection{Unmodified applications on SGX}
\label{sec:intro:sgx}


%One of the motivating examples, for using \libos{} to improve application compatibility,
%is the support of unmodified Linux application
%on the platform of Intel (SGX)~\cite{intelsgx}.
SGX~\cite{intelsgx} are new extensions to the six-generation Intel CPUs,
%provide the hardware support for trustworthy, isolated execution, as part of the sixth-generation Intel CPU extensions.
%Using SGX, application developers 
which can
protect signed application code from attacks in compromised OSes, hypervisors, and other system software.
In the isolated environment of SGX, or {\bf enclaves}, applications can securely utilize the
resources of an untrusted host,
such as a public cloud machine for rent, or a client machine,
with both confidentiality and integrity.
%By running the application code on SGX, the code has 
%emory state inside of the protected code
%to be signed and encrypted, when the code and data leave the CPU package and are stored in the DRAM or swap device.
SGX also offers attestation for the integrity of remote enclaves, as well as proving the integrity of the Intel CPUs.


%A Linux application running on Intel SGX can receive end-to-end protection from the untrusted OSes, but also no longer have a trustworthy OS to faithfully return correct, benign OS features, such as reading a file or creating a thread.
%The untrusted OS can potentially launch attacks through manipulating  
%valid return values to applications, which are known as the Iago attacks.
%The problem of defending against Iago attacks is that these attacks are hard to predict among all the scenarios and corner cases in the full OS functionality of a modern OS like Linux or Windows, given the complexity of OS semantics and the lack of study on untrusted OSes.
%As a result,
%building an ad hoc compatibility layer to implement and defend OS features for general Linux applications in Intel SGX
%not only is cumbersome but also cannot be properly checked for security.

To utilize SGX, common expectation is that developers have to partition a piece of the application code to run inside an enclave.
The restriction is for both security and simplicity reasons.
The enclave code is mostly statically compiled, for making code verification straightforward.
%and thus is easier to sign and verify.
Development of enclave code also involves removing OS function calls and instructions which are not supported in an enclave.
%If users intend to run an unmodified application, SGX imposes several restrictions on running unmodified applications inside an enclave.
%The restrictions are either imposed by the SGX hardware in the run time, or statically by the official Intel SGX SDK (software development kit).
The restriction on the instructions is also for the clarity of application protection.
For example,
%including \code{cpuid} and \code{rdtsc}, for the clarity of shielding these hardware features.
SGX forbids \code{cpuid} in case of combining with the hardware virtualization (VT),
to avoid trapping to hypervisors.
%, which is untrusted in the threat model of SGX.
SGX also forbids \code{rdtsc}, in order to rule out potential physical attacks on the Time Stamp Counter (TSC). 
%The application developers would have to remove these instructions from the applications in order to run inside an enclave.


\issuedone{1.2.c}{discuss challenges of SGX shielding}
SGX excludes OS services from the trust model, except functions which can be fully ported to user space (e.g. \syscall{malloc}).
The absence of trusted OS services is an issue for porting any application.
Existing solutions combines a modified C library with applications, to redirect system interfaces
to the untrusted OS~\cite{osdi16scone,shinde17panoply}.
The problem, however, is in checking the results of system interfaces, because the OS is not trusted. % to faithfully implement OS services.
%Checks against simple attacks are possible,
%such as checking if returned pointers are valid to the enclave regions.
%to \syscall{mmap} which points to existing memory regions that can be corrupted or can leak sensitive information
Previous work~\cite{checkoway13iago} shows that
checking untrusted system interface results can be subtle, because the existing system interfaces are not designed for an untrusted or compromised OS.


In summary, the existing porting models of Intel SGX always requires modifying application binaries, and reasoning about the completeness of checking system interfaces.
This thesis argues that, by introducing a library OS into enclaves,
the interaction with the untrusted OS can be restricted to OS services which have clear semantics for checking.
%an narrowed, fixed enclave interface can be defined, to restrict interaction with the untrusted OS to services that can be explicitly checked.
By implementing the host ABI inside an enclave,
users can easily run an unmodified Linux application, such as an Apache server or an OpenJDK runtime,
with a trusted \graphene{} library OS instance.



\subsection{Multi-process applications}
\label{sec:intro:multiproc}


\issuedone{1.3.b}{Using multi-process as a motivating example}
One characteristic of a UNIX program is the opportunity of utilizing multiple processes, created by either \syscall{fork} or \syscall{exec},
to program self-contained sessions or commands in applications.
Especially, \syscall{fork} is an unique feature in UNIX-style OSes, such as Linux and BSD,
to clone a process into another child process, with isolation from the parent.
%mostly with copy-on-write paging.
%The process state can be easily tore down at exit.
The multi-process abstractions are convenient for creating a temporary session for processing incoming requests or commands, and destroying the session without corrupting the parent process.

Between multiple processes, there are several mechanisms of inter-process communication (IPC)  available for programming.
The Linux IPC combines the UNIX System V features, including message queues and semaphores,
and POSIX abstractions, such as signaling and namespaces.
%The implementation of these mechanisms is idiosyncratic to Linux applications, and has to coordinate several global states across all processes.
Figure~\ref{fig:overview:proc-example} shows a code example of
two Linux programs (``\code{sh}'' and ``\code{kill}'')
running in parallel as part of a multi-process application and communicating with signals.
%Signaling between the parent and child processes
%can happen in several occasions, including processes being terminated accidentally or deliberately, and one process calling the \syscall{kill} system call.
The destination of signaling is determined by a unique process identifier (PID)
known by all processes.
These kinds of identifiers or names are globally shared, as part of the POSIX namespaces,
among applications or processes visible to each other.

 

\begin{figure*}
\begin{minipage}[t]{.65\textwidth}
(Parent process: \code{"sh"})
\lstset{basicstyle=\ttfamily\footnotesize,fontadjust=true,breaklines=true}
\begin{lstlisting}
char pid[10], *argv[]={"kill",pid,0};
itoa(getpid(), pid, 10);
if (!fork()) //clone a process
  execv("/bin/kill", argv);
wait(NULL);  //wait for signal
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{.33\textwidth}
(Child process: \code{"kill"})
\lstset{basicstyle=\ttfamily\footnotesize,fontadjust=true,breaklines=true}
\begin{lstlisting}

pid=atoi(argv[1]);
//send a signal
kill(pid, SIGKILL);

\end{lstlisting}
\end{minipage}
\caption{Sample code for Linux applications using process cloning and inter-process communication (IPC).}
\label{fig:overview:proc-example}
\end{figure*}



Implementing IPC mechanisms in an OS used to rely on a coherent kernel space, but can be challenging when an OS makes the opposite assumption.
%Since coordination is necessary for multi-process applications, 
The easiest design is to store the states and namespace in the kernel memory accessible to all processes.
Sharing kernel states, however, is prone to attacks in an OS with process sandboxing,
or in an application
isolated by hardware like Intel SGX.
An isolated OS design tends to avoid sharing a fully-trusted, coherent kernel space shared with other applications.
For example, on SGX, an enclave cannot share trusted memory with other enclaves.
%The only possible solution without introducing more OS functionality into enclaves is to export the encrypted states to the untrusted kernel, which will suffer significant overheads.


Moreover, not all architectures assume inter-connected, coherent memory.
Several recent multi-CPUs architectures choose not to implement memory coherence for simplicity~\cite{gschwind2007,cascaval2002evaluation}.
Barrelfish~\cite{baumann09barrelfish} demonstrates an efficient OS design, called multikernels, which runs distributed OS nodes on CPUs with inter-node coordination by message passing.
The distributed OS design resonates with the \graphene{} library OS, which uses RPC (remote procedure call) streams to implement multi-process abstractions.
%\graphene{} can be a flexible option for building up compatibility against multi-process applications.
Since \graphene{} does not assume a coherent kernel space, it can be a flexible option
for porting multi-process applications to a variety of OSes and architectures.



\section{Security isolation}
\label{sec:intro:security}

\issue{1.1.d}{separate the motivation for security isolation}




\section{Summary}

This thesis contributes a library OS design, called \graphene{},
which demonstrates the benefits on reusing unmodified Linux applications, upon new hardware or OS prototypes.
Compared with ad-hoc translation layers,
a library OS with a rich of Linux functionality (\graphenesyscallnum{} system calls) can be reused on various host platforms, as an adaptable layer with compatibility.
\graphene{} can adapt to the restrictions and
limited hardware abstractions on a host, with acceptable performance and memory footprint.
This thesis further reasons about the sufficiency of a library OS
for running frequently-reused applications. The reasoning is based on a metric which can evaluate the partial compatibility of a system interface.
\graphene{} prioritizes indispensable system calls over administrative or unpopular features,
to reuse a wide range of applications, from server applications to language runtimes.


\paragraph{Previous publications.}
The initial design of the \graphene{} library OS is presented in \cite{tsai14graphene}, which emphasizes on security isolation, between mutually-untrusted applications.
A later publication~\cite{tsai17graphene-sgx} focuses on porting the host ABI
to Intel SGX, and demonstrates the security benefit 
over a thin redirection layer, and the usability feature to run unmodified applications.
\cite{tsai16apistudy} presents the compatibility metrics for compatibility,
with a study of the Linux API usage among Ubuntu users and applications.

\section{Organization}

The rest of this thesis is organized as follows:
Chapter~\ref{chap:overview} describes the overview of Graphene (including the host ABI and the library OS) and the design principles behind the implementation.
Chapter~\ref{chap:abi} formally defines the host ABI, and provides a specification of the host-specific PAL (platform adaption layer).
Chapter~\ref{chap:libos} discusses the library OS in details.
Chapter~\ref{chap:linux} describes the PAL on Linux, as an example of implementing the host ABI and security isolation between library OS instances.
Chapter~\ref{chap:sgx} discusses SGX-specific challenges to application porting, and the PAL implementation inside a SGX enclave.
Chapter~\ref{chap:eval} evaluates the performance and memory footprint of \graphene{} and \graphenesgx{},
and presents a security study.
Chapter~\ref{chap:metric} presents a quantitative metric for compatibility,
to evaluate the completeness of Linux functionality in \graphene{}.
Chapter~\ref{chap:study} presets a study of the Linux API importance, to give an insight about prioritizing API implementation.
%uses the metrics of API importance, to study the usage of Linux interfaces in applications.
Chapter~\ref{chap:related} discusses the related work.
Chapter~\ref{chap:conclusion} concludes the thesis.
