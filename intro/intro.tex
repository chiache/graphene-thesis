\chapter{Introduction}
\label{chap:intro}


Operating systems simplify the programming of an application, to utilize a wide range of hardware.
A UNIX-style OS
encapsulates hardware resources and abstractions~\cite{ritchie74unix}, in a system interface programmable inside applications.
Therefore, applications can be programmed against a hardware-independent, extended machine specified by the system interface~\cite{dhamdhere2007os-textbook},
instead of individual physical machines.
%Application portability requires an OS to export a system interface
%independent from hardware configurations,
%such as different CPU models, memory of different capacity, and various I/O devices.
%The only exception is the portability across CPU architectures,
%Otherwise, application developers would expect an application, built without dependency to %specific hardware, to be reusable in an OS regardless of what hardware users choose.
%The same assumption on application portability has been shared among
Most modern OSes,
including Linux, Windows, BSD,
and POSIX-style OSes,
%to make applications adaptable and widely distributable.
accomodate portable applications~\cite{linux-standard-base,quarterman85bsd,ieee-posix}.
%share the merit of application portability.



A prerequisite to programming a portable application
is to have a consistent system interface which stays compatible as applications are previously programmed.
Because an OS can be constantly under extension for supporting new hardware,
OS developers are responsible of maintaining a compatible system interface to keep applications valid.
OS developers usaully face challenges
when a new hardware leaks out of the abstractions encapsulated by the system interface.
If OS developers have to extend the system interface
to facilitate the programming of a new hardware, 
the OS loses the compatibility for existing applications 
to utilize this hardware.
Extensions to a system interface are usually in the form of \syscall{ioctl} operations in a POSIX-style OS,
or new system call options such as the \code{MAP\_HUGETLB} flags for \syscall{mmap}.
Unless a new hardware can be transparently adopted in an OS,
applications will lag behind the OS to be deployed on the hardware.



As an extreme case, some hardware make unusual design decisions which contradicts OS or application assumptions,
thus affecting the OS's ability to stay
compatible against applications.
The hardware are usually cutting-edge inventions or research prototypes.
Researchers design
these hardware
to explore opportunities of tweaking existing assumptions,
in seek of revolutionary results.
%making the implementation of a compatible system interface
%even more challenging.
An example %of a disruptive hardware design
is {\bf SGX (software guard extensions)}~\cite{intelsgx},
an Intel CPU feature which allows applications to protect themselves from malicious OSes and administrators.
SGX raises several compatibility issues, including changing the trusted nature of OS services~\cite{baumann14haven,osdi16scone,tsai17graphene-sgx}, and forbidding the sharing of isolated application memory~\cite{shinde17panoply}.
Another example is an asymmetric multiprocessing architecture~\cite{},
or an architecture without inter-connected, coherent memories~\cite{gschwind2007,cascaval2002evaluation}. 
%Despite the benefits of SGX on application protection,
%SGX requires changing the applications to defend against malicious OS services,
%and to work around several compatibility issues of the restricted ISA of SGX (more details discussed in Section~\ref{sec:intro:sgx}).
%Especially, the size and subtlety of the Linux or Windows system interface
%makes it unsuitable for adopting applications to SGX~\cite{checkoway13iago}, because SGX has fundamentally changed the nature of OS services.
%Several recent publications mitigate part of the compatibility issue for deploying applications on SGX~\cite{baumann14haven,osdi16scone,shinde17panoply}.
For these hardware, compatibility issues are likely to be a distraction, which researchers cannot avoid for commercializing the hardware.



The key challenge to maintaining the compatibility is to reproduce
the idiosyncratic behavior and semantic
of a system interface.
The goal of OS development is to bridge the "semantic gap" between the system interface and the low-level hardware abstractions~\cite{tanenbaum19os-textbook}.
The design of a long-lasting system interface, such as Linux system calls or POSIX API, is influenced by the design of plenty of pre-existing hardware,
and thus is difficult to change for another disruptive hardware.
%For example, a monolithic OS, such as Linux or Windows, assumes a unified kernel, which mediates all operations from applications to request hardware resources and abstractions.
Also, an OS prototype built from scratch
can redefine a system interface which accommodates a new hardware, or optimizes for it~\cite{baumann09barrelfish,peter14arrakis,belay14ix}.
%and may require compatibility against deployed applications.
%often chooses to adopt the system interface of a popular OS standard, such as POSIX or Linux, to reuse applications already under deployment.
%It is a practical move to implement system interfaces from a popular open OS such a Linux,
%to demonstrate the benefits of using an OS prototype
%on running certain native applications.
%An OS can define a system interface with up to hundreds or thousands of functions~\cite{ieee-posix, linux-man-syscall}. %nearly impossible to fully implement from scratch.
However, to be compatible with existing applications,
building a translation or emulation layer for reproducing the former OS behavior and semantic, upon either an adapted system interface or an OS prototype, is still necessary.



The translation (or emulation) of a system interface
can benefit from virtualizing the upper layers of OS components,
or the whole OS. 
A key insight is to reduce the ad-hoc development effort for translating on a specific hardware or host interface, by reusing a virtualized OS implementation.
Virtualization separates the translation of an idiosyncratic system interface,
using an intermediate interface which drops the assumptions
from both the system interface and the underlying hardware or OS.
A common solution is to run a VM (virtual machine) with an unmodified OS kernel, upon a virtual hardware interface.
The virtual hardware interface 
assumes generic, standard virtual hardware, %including CPU architecture, memory and I/O devices, 
which are compatible with an unmodified OS (e.g., Linux kernel) in the virtual machine.
The caveat for a VM
%A virtual machine conveniently reuses existing OS implementation
%for reproducing the system interface,
is that it still relies on an assumption
that the CPU architecture has virtualization support,
such as Intel VT (virtualization technology).
As an alternative to a VM, OS developers can partition an OS instead of reusing the whole OS,
using a "pinch point" found inside the OS implementation,
with even simpler specification and assumption than a virtual hardware interface.





This thesis describes an OS design which resolves compatibility issues, for either a new hardware or a OS prototype.
%implementation of compatibility in an OS, in case the OS developers intend to extend the OS for new hardware.
%reducing the difficulty of retaining compatibility
%is to reduce the complexity of system interface which has to be reproduced, to achieve compatibility against existing applications.
%when extending the OS implementation.
This thesis demonstrates that OS developers need not to repeat the implementation of
the whole system interface,
but develop a simple host ABI for virtualizing OS components.
% when the goal is to retain the compatibility for a certain amount of applications, on an unconventional physical machine.
%For the OS design, this thesis presents a narrow system interface to each hosts,
%or {\em host ABI}.
%to be implemented for each host platforms.
%the key to facilitating the compatibility in an OS.
%The host ABI must
%contain typical OS functions needed by every applications,
%but be simple enough for porting.
%defined to be completely independent from the physical machines,
%and contain abstractions that are easy to implement in most commodity OSes.
Above the host ABI, we proposes using a {\bf library OS}~\cite{porter11drawbridge,engler95exokernel,libra,unikernels},
to reproduce a system interface for applications.
%that the existing applications imperatively depend on.
%A \libos{} is different from a translation layer which maps one set of system interfaces to another, nor is it the same as wrapper functions for formerly defined interfaces.
%A \libos{} implements an operating system instance separated from the host, upon a standalone host interfaces similar to a set of virtualized hardware interfaces, or para-virtualized hypercalls.
%To make the library OS practical enough to benefit OS research,
This thesis targets the compatibility against commercially-used, popular Linux applications, including server applications, command-line programs, and language runtimes.
%This thesis shows that the defined host ABI is sufficient to implement a rich of OS functionality for reusing the said applications.


%This thesis shows that a library OS can implement a substantial amount of OS features needed by the reused applications,
%and the host ABI can be easily ported to a new physical machine or an alternative OS.
%using a host interface defined with simplicity and minimal assumptions. This \libos{} design, alone with the host interface, is potentially stackable on various operating systems, to benefit both backward and forward compatibility.


Based on this OS design, we present {\bf \graphene{}}, a library OS for running unmodified Linux applications on various OSes and hardware, including SGX as a running example.
%This thesis shows the embodiment of an OS design as the \graphene{} library OS.
%The  library OS can run a wide range of unmodified Linux applications,
%including server-type applications, command-line programs, and language runtimes, on a set of host OSes and hardware platforms.
\graphene{} implements \graphenesyscalls{} out of \linuxsyscalls{} Linux system calls (version 4.0), with a narrowed host ABI containing \palcalls{} functions.
Part of the host ABI is inherited from \drawbridge{}~\cite{porter11drawbridge}, a prior library OS which has demonstrated compatibility benefit over
Windows applications.
The \drawbridge{} design is later adopted by Bascule~\cite{baumann13bascule} and Haven~\cite{baumann14haven}, to show the feasibility of implementing single-process, Linux functionality, and porting to Intel SGX.

Established upon the previous work, \graphene{} holds the following key contributions:
\begin{compactenum}
\item \graphene{} explores and justifies the feasibility of building a library OS for resolving compatibility issues on various OSes and hardware.
%(1) Reasoning about the portability and completeness of functionality.
% of the host ABI and library OS design for both
\item \graphene{} faithfully implements a rich of native Linux system calls, including several challenging features which are specific to Linux or UNIX,
such as multi-process abstractions.
\item \graphene{} shows it possible to engineer a library OS
with practical performance overhead,
and memory footprint close to a Linux process.
\item Comparable to a VM, \graphene{} can enforce strong security isolation
between mutually-untrusted applications,
with a narrowed attack surface to the host kernel (more in Section~\ref{sec:intro:security}).
\end{compactenum}


\paragraph{Compatibility evaluation and study.}
This thesis studies the compatibility requirement in Linux and POSIX
from the perspectives of applications and users.
The study begins with building a metric for compatibility,
weighted by the API usage in applications,
and application importance (or popularity).
%for measuring and implementing compatibility. The design principle applies to either a commodity OS, a newly-built OS prototype, or the \graphene{} library OS.
%This thesis shows that the compatibility against the existing applications, in an OS, can be measured and incrementally improved by scientific approach.
%Using a metric that is weighted by the usage of system interfaces in a large sample of commonly used applications, as well as the popularity of the sampled applications,
Using the metric,
OS developers can quantitatively determine the priority in implementing a system interface,
and evaluate the developed results.
The study shows that most applications do not require
half of the Linux system calls,
which are either for administrative use (e.g., halting the machine), or unpopular among applications.



\section{Motivating Examples}

This section shows two examples in which developing a compatible OS for existing applications can be challenging, to motivate the library OS design.


\subsection{Unmodified applications on SGX}
\label{sec:intro:sgx}


\issue{1.1.b}{need clarifying the specification}
%One of the motivating examples, for using \libos{} to improve application compatibility,
%is the support of unmodified Linux application
%on the platform of Intel (SGX)~\cite{intelsgx}.
SGX~\cite{intelsgx} are new extensions to the six-generation Intel CPUs,
%provide the hardware support for trustworthy, isolated execution, as part of the sixth-generation Intel CPU extensions.
%Using SGX, application developers 
which can
protect signed application code from attacks in compromised OSes, hypervisors, and other system software.
In the isolated environment of SGX, or {\bf enclaves}, applications can securely utilize the
resources of an untrusted host,
such as a public cloud machine for rent, or a client machine,
with both confidentiality and integrity.
%By running the application code on SGX, the code has 
%emory state inside of the protected code
%to be signed and encrypted, when the code and data leave the CPU package and are stored in the DRAM or swap device.
SGX also offers attestation for the integrity of remote enclaves, as well as proving the integrity of the Intel CPUs.


%A Linux application running on Intel SGX can receive end-to-end protection from the untrusted OSes, but also no longer have a trustworthy OS to faithfully return correct, benign OS features, such as reading a file or creating a thread.
%The untrusted OS can potentially launch attacks through manipulating  
%valid return values to applications, which are known as the Iago attacks.
%The problem of defending against Iago attacks is that these attacks are hard to predict among all the scenarios and corner cases in the full OS functionality of a modern OS like Linux or Windows, given the complexity of OS semantics and the lack of study on untrusted OSes.
%As a result,
%building an ad hoc compatibility layer to implement and defend OS features for general Linux applications in Intel SGX
%not only is cumbersome but also cannot be properly checked for security.

To utilize SGX, common expectation is that developers have to partition a piece of the application code to run inside an enclave.
The restriction is for both security and simplicity reasons.
The enclave code is mostly statically compiled, for making code verification straightforward.
%and thus is easier to sign and verify.
Development of enclave code also involves removing OS function calls and instructions which are not supported in an enclave.
%If users intend to run an unmodified application, SGX imposes several restrictions on running unmodified applications inside an enclave.
%The restrictions are either imposed by the SGX hardware in the run time, or statically by the official Intel SGX SDK (software development kit).
The restriction on the instructions is also for the clarity of application protection.
For example,
%including \code{cpuid} and \code{rdtsc}, for the clarity of shielding these hardware features.
SGX forbids \code{cpuid} in case of combining with the hardware virtualization (VT),
to avoid trapping to hypervisors.
%, which is untrusted in the threat model of SGX.
SGX also forbids \code{rdtsc}, in order to rule out potential physical attacks on the Time Stamp Counter (TSC). 
%The application developers would have to remove these instructions from the applications in order to run inside an enclave.



SGX excludes OS services from the trust model, except functions which can be fully ported to user space (e.g. \syscall{malloc}).
The absence of trusted OS services is an issue for porting any application.
Existing solutions combines a modified C library with applications, to redirect system interfaces
to the untrusted OS~\cite{osdi16scone,shinde17panoply}.
The problem, however, is in checking the results of system interfaces, because the OS is not trusted. % to faithfully implement OS services.
%Checks against simple attacks are possible,
%such as checking if returned pointers are valid to the enclave regions.
%to \syscall{mmap} which points to existing memory regions that can be corrupted or can leak sensitive information
Previous work~\cite{checkoway13iago} shows that
checking untrusted system interface results can be subtle, because the existing system interfaces are not designed for an untrusted or compromised OS.


In summary, the existing porting models of Intel SGX always requires modifying application binaries, and reasoning about the completeness of checking system interfaces.
This thesis argues that, by introducing a library OS into enclaves,
the interaction with the untrusted OS can be restricted to OS services which have clear semantics for checking.
%an narrowed, fixed enclave interface can be defined, to restrict interaction with the untrusted OS to services that can be explicitly checked.
By implementing the host ABI inside an enclave,
users can easily run an unmodified Linux application, such as an Apache server or an OpenJDK runtime,
with a trusted \graphene{} library OS instance.



\subsection{Multi-process applications}
\label{sec:intro:multiproc}


One characteristic of a UNIX program is the opportunity of utilizing multiple processes, created by either \syscall{fork} or \syscall{exec},
to program self-contained sessions or commands in applications.
Especially, \syscall{fork} is an unique feature in UNIX-style OSes, such as Linux and BSD,
to clone a process into another child process, with isolation from the parent.
%mostly with copy-on-write paging.
%The process state can be easily tore down at exit.
The multi-process abstractions are convenient for creating a temporary session for processing incoming requests or commands, and destroying the session without corrupting the parent process.

Between multiple processes, there are several mechanisms of inter-process communication (IPC)  available for programming.
The Linux IPC combines the UNIX System V features, including message queues and semaphores,
and POSIX abstractions, such as signaling and namespaces.
%The implementation of these mechanisms is idiosyncratic to Linux applications, and has to coordinate several global states across all processes.
Figure~\ref{fig:overview:proc-example} shows a code example of
two Linux programs (``\code{sh}'' and ``\code{kill}'')
running in parallel as part of a multi-process application and communicating with signals.
%Signaling between the parent and child processes
%can happen in several occasions, including processes being terminated accidentally or deliberately, and one process calling the \syscall{kill} system call.
The destination of signaling is determined by a unique process identifier (PID)
known by all processes.
These kinds of identifiers or names are globally shared, as part of the POSIX namespaces,
among applications or processes visible to each other.

 

\begin{figure*}
\begin{minipage}[t]{.65\textwidth}
(Parent process: \code{"sh"})
\lstset{basicstyle=\ttfamily\footnotesize,fontadjust=true,breaklines=true}
\begin{lstlisting}
char pid[10], *argv[]={"kill",pid,0};
itoa(getpid(), pid, 10);
if (!fork()) //clone a process
  execv("/bin/kill", argv);
wait(NULL);  //wait for signal
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{.33\textwidth}
(Child process: \code{"kill"})
\lstset{basicstyle=\ttfamily\footnotesize,fontadjust=true,breaklines=true}
\begin{lstlisting}

pid=atoi(argv[1]);
//send a signal
kill(pid, SIGKILL);

\end{lstlisting}
\end{minipage}
\caption{Sample code for Linux applications using process cloning and inter-process communication (IPC).}
\label{fig:overview:proc-example}
\end{figure*}



Implementing IPC mechanisms in an OS used to rely on a coherent kernel space, but can be challenging when an OS makes the opposite assumption.
%Since coordination is necessary for multi-process applications, 
The easiest design is to store the states and namespace in the kernel memory accessible to all processes.
Sharing kernel states, however, is prone to attacks in an OS with process sandboxing,
or in an application
isolated by hardware like Intel SGX.
An isolated OS design tends to avoid sharing a fully-trusted, coherent kernel space shared with other applications.
For example, on SGX, an enclave cannot share trusted memory with other enclaves.
%The only possible solution without introducing more OS functionality into enclaves is to export the encrypted states to the untrusted kernel, which will suffer significant overheads.


Moreover, not all architectures assume inter-connected, coherent memory.
Several recent multi-CPUs architectures choose not to implement memory coherence for simplicity~\cite{gschwind2007,cascaval2002evaluation}.
Barrelfish~\cite{baumann09barrelfish} demonstrates an efficient OS design, called multikernels, which runs distributed OS nodes on CPUs with inter-node coordination by message passing.
The distributed OS design resonates with the \graphene{} library OS, which uses RPC (remote procedure call) streams to implement multi-process abstractions.
%\graphene{} can be a flexible option for building up compatibility against multi-process applications.
Since \graphene{} does not assume a coherent kernel space, it can be a flexible option
for porting multi-process applications to a variety of OSes and architectures.



\section{Security isolation}
\label{sec:intro:security}

\placeholder{}

%Besides emulating OS abstractions, \graphene{} also provides a reasonable model of enforcing security isolation among applications launched by mutually untrusting users.
%Similar as the complexity of emulating all the abstractions,
%the security isolation on a monolithic OS can be delicate and prone to mistake,
%if each abstraction is controlled individually.
%\graphene{} simplifies the isolation of OS abstractions
%down to three host abstractions: files, network connections, and RPC streams.
%For these host abstractions, \graphene{} enforces isolation policies in the styles
%commonly used by security experts:
%white-lists for file access, firewall rules for network connection,
%and simple ``Chinese Wall'' isolation for RPC streams.
%We show that, by isolating these host abstractions,
%the numerous OS abstractions emulated by the \liboses{} will be utterly isolated,
%without making significant effort to build individual access control.
%The isolation model is fully portable to every host platforms,
%including the host with SGX enclaves, where no trusted host monitor is present



\section{Summary}

This thesis contributes an open, practical, library OS design, called \graphene{},
which demonstrates benefit on reusing unmodified Linux applications, upon new hardware or OS prototypes.
Compared with ad-hoc translation layers,
a library OS with a rich of Linux functionality (\graphenesyscalls{} system calls implemented) can be reused on various host platforms, as an adaptable layer with compatibility.
\graphene{} can adapt to the restrictions and
limited hardware abstractions on a host, with acceptable performance and memory footprint.
This thesis further reasons about the sufficiency of a library OS
for running frequently-reused applications. The reasoning is based on a metric which can evaluate the partial compatibility of a system interface.
\graphene{} prioritizes indispensable system calls over administrative or unpopular features,
to reuse a wide range of applications, from server applications to language runtimes.


\paragraph{Previous publications.}
The initial design of the \graphene{} library OS is presented in \cite{tsai14graphene}, which emphasizes on security isolation, between mutually-untrusted applications.
A later publication~\cite{tsai17graphene-sgx} focuses on porting the host ABI
to Intel SGX, and demonstrates the security benefit 
over a thin redirection layer, and the usability feature to run unmodified applications.
\cite{tsai16apistudy} presents the compatibility metrics for compatibility,
with a study of the Linux API usage among Ubuntu users and applications.

\section{Organization}

The rest of this thesis is organized as follows:
Chapter~\ref{chap:overview} describes the overview of Graphene (including the host ABI and the library OS) and the design principles behind the implementation.
Chapter~\ref{chap:abi} formally defines the host ABI.
Chapter~\ref{chap:libos} discusses the library OS in details.
Chapter~\ref{chap:linux} describes the PAL (platform-adaption layer) on Linux, as an example of implementing the host ABI and security isolation between library OS instances.
Chapter~\ref{chap:sgx} discusses SGX-specific challenges to application porting, and the PAL implementation inside a SGX enclave.
Chapter~\ref{chap:eval} evaluates the performance and memory footprint of \graphene{} and \graphenesgx{},
and presents a security study of \graphene{}.
Chapter~\ref{chap:metric} presents a quantitative metric for compatibility,
to evaluate the completeness of Linux functionality in \graphene{}.
Chapter~\ref{chap:study} presets a study of the Linux API importance, to give an insight about prioritizing API implementation.
%uses the metrics of API importance, to study the usage of Linux interfaces in applications.
Chapter~\ref{chap:related} discusses the related work.
Chapter~\ref{chap:conclusion} concludes the thesis.
